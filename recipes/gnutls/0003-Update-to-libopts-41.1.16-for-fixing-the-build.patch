From a23f538e8f045ff5894115910405669137349d59 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?= <sebastian@centricular.com>
Date: Sat, 15 Aug 2015 11:22:05 +0200
Subject: [PATCH] Update to libopts-41.1.16 for fixing the build

The tarball contains autogenerated files that depend on a specific version of
libopts... but the libopts version contained in the tarball is not that one.
---
 src/libopts/COPYING.gplv3           |   2 +-
 src/libopts/COPYING.lgplv3          |   2 +-
 src/libopts/COPYING.mbsd            |   1 +
 src/libopts/Makefile.am             |  52 +++++++-----
 src/libopts/Makefile.in             | 156 +++++++++++++++++++++++++++---------
 src/libopts/README                  |   2 +-
 src/libopts/ag-char-map.h           |   4 +-
 src/libopts/alias.c                 |   2 +-
 src/libopts/ao-strs.c               |   2 +-
 src/libopts/ao-strs.h               |   2 +-
 src/libopts/autoopts.c              |   8 +-
 src/libopts/autoopts.h              |  24 +++---
 src/libopts/autoopts/options.h      | 136 ++++++++++++++++---------------
 src/libopts/autoopts/project.h      |   2 +-
 src/libopts/autoopts/usage-txt.h    |  24 +++---
 src/libopts/boolean.c               |  10 +--
 src/libopts/check.c                 |   2 +-
 src/libopts/compat/compat.h         |   2 +-
 src/libopts/compat/pathfind.c       |  24 +++---
 src/libopts/compat/windows-config.h |   2 +-
 src/libopts/configfile.c            |  97 +++++++++++-----------
 src/libopts/cook.c                  |  18 ++---
 src/libopts/enum.c                  |  28 +++----
 src/libopts/env.c                   |   8 +-
 src/libopts/file.c                  |  12 +--
 src/libopts/find.c                  |  16 ++--
 src/libopts/genshell.c              |  48 +++++------
 src/libopts/genshell.h              |   4 +-
 src/libopts/gettext.h               |   2 +-
 src/libopts/init.c                  |  12 +--
 src/libopts/intprops.h              |   2 +-
 src/libopts/libopts.c               |   2 +
 src/libopts/load.c                  |  16 ++--
 src/libopts/m4/libopts.m4           |  30 +++----
 src/libopts/m4/liboptschk.m4        |   2 +-
 src/libopts/m4/stdnoreturn.m4       |   2 +-
 src/libopts/makeshell.c             |  33 ++++----
 src/libopts/nested.c                |  66 +++++++--------
 src/libopts/numeric.c               |  18 ++---
 src/libopts/option-value-type.c     |   2 +-
 src/libopts/option-xat-attribute.c  |   2 +-
 src/libopts/parse-duration.c        |   2 +-
 src/libopts/parse-duration.h        |   2 +-
 src/libopts/pgusage.c               |  10 +--
 src/libopts/proto.h                 |   4 +-
 src/libopts/putshell.c              |  14 ++--
 src/libopts/reset.c                 |   8 +-
 src/libopts/restore.c               |  34 ++++----
 src/libopts/save.c                  |  32 ++++----
 src/libopts/sort.c                  |  10 +--
 src/libopts/stack.c                 |  30 +++----
 src/libopts/stdnoreturn.in.h        |   2 +-
 src/libopts/streqvcmp.c             |  22 ++---
 src/libopts/text_mmap.c             |  20 ++---
 src/libopts/time.c                  |  10 +--
 src/libopts/tokenize.c              |  48 +++++------
 src/libopts/usage.c                 |  12 +--
 src/libopts/version.c               |  18 ++---
 58 files changed, 627 insertions(+), 530 deletions(-)

diff --git a/src/libopts/COPYING.gplv3 b/src/libopts/COPYING.gplv3
index 065b7a6..26d6fd2 100644
--- a/src/libopts/COPYING.gplv3
+++ b/src/libopts/COPYING.gplv3
@@ -1,7 +1,7 @@
                     GNU GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007
 
- Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
diff --git a/src/libopts/COPYING.lgplv3 b/src/libopts/COPYING.lgplv3
index 3deaacb..b6db232 100644
--- a/src/libopts/COPYING.lgplv3
+++ b/src/libopts/COPYING.lgplv3
@@ -1,7 +1,7 @@
 		   GNU LESSER GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007
 
- Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
diff --git a/src/libopts/COPYING.mbsd b/src/libopts/COPYING.mbsd
index 8a70427..74948be 100644
--- a/src/libopts/COPYING.mbsd
+++ b/src/libopts/COPYING.mbsd
@@ -1,3 +1,4 @@
+Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 
diff --git a/src/libopts/Makefile.am b/src/libopts/Makefile.am
index 413fc4d..63fcffb 100644
--- a/src/libopts/Makefile.am
+++ b/src/libopts/Makefile.am
@@ -1,15 +1,23 @@
 ## LIBOPTS Makefile
 MAINTAINERCLEANFILES    = Makefile.in
-
+if INSTALL_LIBOPTS
+lib_LTLIBRARIES         = libopts.la
+else
 noinst_LTLIBRARIES      = libopts.la
- 
+endif
 libopts_la_SOURCES      = libopts.c
-libopts_la_CPPFLAGS     = -I$(top_srcdir)
-libopts_la_LIBADD       = $(LTLIBINTL)
+libopts_la_CPPFLAGS     = -I$(srcdir)
+libopts_la_LDFLAGS      = -version-info  41:1:16
 EXTRA_DIST		=
 BUILT_SOURCES		=
 MOSTLYCLEANFILES	=
 
+libopts.c:		$(BUILT_SOURCES)
+	@: do-nothing rule to avoid default SCCS get
+
+
+# Makefile fragment from gnulib-s stdnoreturn module:
+#
 _NORETURN_H=$(srcdir)/compat/_Noreturn.h
 EXTRA_DIST += $(srcdir)/compat/_Noreturn.h
 BUILT_SOURCES += $(STDNORETURN_H)
@@ -27,25 +35,25 @@ stdnoreturn.h: $(top_builddir)/config.status
 endif
 MOSTLYCLEANFILES += stdnoreturn.h stdnoreturn.h-t
 EXTRA_DIST += stdnoreturn.in.h
- 
+
 EXTRA_DIST += \
-    COPYING.gplv3           COPYING.lgplv3          COPYING.mbsd  \
-    MakeDefs.inc            README                  ag-char-map.h  \
-    alias.c                 ao-strs.c               ao-strs.h  \
-    autoopts/options.h      autoopts/project.h      autoopts/usage-txt.h  \
-    autoopts.c              autoopts.h              boolean.c  \
-    check.c                 compat/strdup.c         compat/snprintf.c  \
-    compat/compat.h         compat/_Noreturn.h      compat/pathfind.c  \
-    compat/windows-config.h compat/strchr.c         configfile.c  \
-    cook.c                  enum.c                  env.c  \
-    file.c                  find.c                  genshell.c  \
-    genshell.h              gettext.h               init.c  \
-    intprops.h              load.c                  m4/libopts.m4  \
-    m4/liboptschk.m4        m4/stdnoreturn.m4       makeshell.c  \
-    nested.c                numeric.c               option-value-type.c  \
-    option-value-type.h     option-xat-attribute.c  option-xat-attribute.h  \
-    parse-duration.c        parse-duration.h        pgusage.c  \
-    proto.h                 putshell.c              reset.c  \
+    ag-char-map.h           alias.c                 ao-strs.c  \
+    ao-strs.h               autoopts/project.h      autoopts/usage-txt.h  \
+    autoopts/options.h      autoopts.c              autoopts.h  \
+    boolean.c               check.c                 compat/compat.h  \
+    compat/strchr.c         compat/pathfind.c       compat/_Noreturn.h  \
+    compat/snprintf.c       compat/windows-config.h compat/strdup.c  \
+    configfile.c            cook.c                  COPYING.gplv3  \
+    COPYING.lgplv3          COPYING.mbsd            enum.c  \
+    env.c                   file.c                  find.c  \
+    genshell.c              genshell.h              gettext.h  \
+    init.c                  intprops.h              load.c  \
+    m4/liboptschk.m4        m4/libopts.m4           m4/stdnoreturn.m4  \
+    MakeDefs.inc            makeshell.c             nested.c  \
+    numeric.c               option-value-type.c     option-value-type.h  \
+    option-xat-attribute.c  option-xat-attribute.h  parse-duration.c  \
+    parse-duration.h        pgusage.c               proto.h  \
+    putshell.c              README                  reset.c  \
     restore.c               save.c                  sort.c  \
     stack.c                 stdnoreturn.in.h        streqvcmp.c  \
     text_mmap.c             time.c                  tokenize.c  \
diff --git a/src/libopts/Makefile.in b/src/libopts/Makefile.in
index 0671eac..e9b7a9c 100644
--- a/src/libopts/Makefile.in
+++ b/src/libopts/Makefile.in
@@ -129,7 +129,6 @@ am__aclocal_m4_deps = $(top_srcdir)/src/gl/m4/arpa_inet_h.m4 \
 	$(top_srcdir)/gl/m4/byteswap.m4 $(top_srcdir)/gl/m4/errno_h.m4 \
 	$(top_srcdir)/gl/m4/exponentd.m4 \
 	$(top_srcdir)/gl/m4/extensions.m4 \
-	$(top_srcdir)/gl/m4/extern-inline.m4 \
 	$(top_srcdir)/gl/m4/fcntl_h.m4 $(top_srcdir)/gl/m4/fdopen.m4 \
 	$(top_srcdir)/gl/m4/float_h.m4 $(top_srcdir)/gl/m4/fpieee.m4 \
 	$(top_srcdir)/gl/m4/fseeko.m4 $(top_srcdir)/gl/m4/fstat.m4 \
@@ -182,10 +181,10 @@ am__aclocal_m4_deps = $(top_srcdir)/src/gl/m4/arpa_inet_h.m4 \
 	$(top_srcdir)/gl/m4/vsnprintf.m4 \
 	$(top_srcdir)/gl/m4/warn-on-use.m4 \
 	$(top_srcdir)/gl/m4/warnings.m4 $(top_srcdir)/gl/m4/wchar_h.m4 \
-	$(top_srcdir)/m4/fcntl-o.m4 $(top_srcdir)/m4/gettext.m4 \
-	$(top_srcdir)/m4/gtk-doc.m4 $(top_srcdir)/m4/guile.m4 \
-	$(top_srcdir)/m4/hooks.m4 $(top_srcdir)/m4/iconv.m4 \
-	$(top_srcdir)/m4/intlmacosx.m4 \
+	$(top_srcdir)/m4/extern-inline.m4 $(top_srcdir)/m4/fcntl-o.m4 \
+	$(top_srcdir)/m4/gettext.m4 $(top_srcdir)/m4/gtk-doc.m4 \
+	$(top_srcdir)/m4/guile.m4 $(top_srcdir)/m4/hooks.m4 \
+	$(top_srcdir)/m4/iconv.m4 $(top_srcdir)/m4/intlmacosx.m4 \
 	$(top_srcdir)/m4/inttypes-pri.m4 \
 	$(top_srcdir)/m4/inttypes_h.m4 $(top_srcdir)/m4/lib-ld.m4 \
 	$(top_srcdir)/m4/lib-link.m4 $(top_srcdir)/m4/lib-prefix.m4 \
@@ -204,15 +203,47 @@ mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
-LTLIBRARIES = $(noinst_LTLIBRARIES)
-am__DEPENDENCIES_1 =
-libopts_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(libdir)"
+LTLIBRARIES = $(lib_LTLIBRARIES) $(noinst_LTLIBRARIES)
+libopts_la_LIBADD =
 am_libopts_la_OBJECTS = libopts_la-libopts.lo
 libopts_la_OBJECTS = $(am_libopts_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
 am__v_lt_0 = --silent
 am__v_lt_1 = 
+libopts_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libopts_la_LDFLAGS) $(LDFLAGS) -o $@
+@INSTALL_LIBOPTS_FALSE@am_libopts_la_rpath =
+@INSTALL_LIBOPTS_TRUE@am_libopts_la_rpath = -rpath $(libdir)
 AM_V_P = $(am__v_P_@AM_V@)
 am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
 am__v_P_0 = false
@@ -912,6 +943,7 @@ LT_REVISION = @LT_REVISION@
 LT_SSL_AGE = @LT_SSL_AGE@
 LT_SSL_CURRENT = @LT_SSL_CURRENT@
 LT_SSL_REVISION = @LT_SSL_REVISION@
+LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
 MAJOR_VERSION = @MAJOR_VERSION@
 MAKEINFO = @MAKEINFO@
 MANIFEST_TOOL = @MANIFEST_TOOL@
@@ -1241,27 +1273,31 @@ top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 MAINTAINERCLEANFILES = Makefile.in
-noinst_LTLIBRARIES = libopts.la
+@INSTALL_LIBOPTS_TRUE@lib_LTLIBRARIES = libopts.la
+@INSTALL_LIBOPTS_FALSE@noinst_LTLIBRARIES = libopts.la
 libopts_la_SOURCES = libopts.c
-libopts_la_CPPFLAGS = -I$(top_srcdir)
-libopts_la_LIBADD = $(LTLIBINTL)
+libopts_la_CPPFLAGS = -I$(srcdir)
+libopts_la_LDFLAGS = -version-info  41:1:16
 EXTRA_DIST = $(srcdir)/compat/_Noreturn.h stdnoreturn.in.h \
-	COPYING.gplv3 COPYING.lgplv3 COPYING.mbsd MakeDefs.inc README \
-	ag-char-map.h alias.c ao-strs.c ao-strs.h autoopts/options.h \
-	autoopts/project.h autoopts/usage-txt.h autoopts.c autoopts.h \
-	boolean.c check.c compat/strdup.c compat/snprintf.c \
-	compat/compat.h compat/_Noreturn.h compat/pathfind.c \
-	compat/windows-config.h compat/strchr.c configfile.c cook.c \
-	enum.c env.c file.c find.c genshell.c genshell.h gettext.h \
-	init.c intprops.h load.c m4/libopts.m4 m4/liboptschk.m4 \
-	m4/stdnoreturn.m4 makeshell.c nested.c numeric.c \
+	ag-char-map.h alias.c ao-strs.c ao-strs.h autoopts/project.h \
+	autoopts/usage-txt.h autoopts/options.h autoopts.c autoopts.h \
+	boolean.c check.c compat/compat.h compat/strchr.c \
+	compat/pathfind.c compat/_Noreturn.h compat/snprintf.c \
+	compat/windows-config.h compat/strdup.c configfile.c cook.c \
+	COPYING.gplv3 COPYING.lgplv3 COPYING.mbsd enum.c env.c file.c \
+	find.c genshell.c genshell.h gettext.h init.c intprops.h \
+	load.c m4/liboptschk.m4 m4/libopts.m4 m4/stdnoreturn.m4 \
+	MakeDefs.inc makeshell.c nested.c numeric.c \
 	option-value-type.c option-value-type.h option-xat-attribute.c \
 	option-xat-attribute.h parse-duration.c parse-duration.h \
-	pgusage.c proto.h putshell.c reset.c restore.c save.c sort.c \
-	stack.c stdnoreturn.in.h streqvcmp.c text_mmap.c time.c \
+	pgusage.c proto.h putshell.c README reset.c restore.c save.c \
+	sort.c stack.c stdnoreturn.in.h streqvcmp.c text_mmap.c time.c \
 	tokenize.c usage.c version.c
 BUILT_SOURCES = $(STDNORETURN_H)
 MOSTLYCLEANFILES = stdnoreturn.h stdnoreturn.h-t
+
+# Makefile fragment from gnulib-s stdnoreturn module:
+#
 _NORETURN_H = $(srcdir)/compat/_Noreturn.h
 all: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) all-am
@@ -1298,6 +1334,41 @@ $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(am__aclocal_m4_deps):
 
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(libdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(libdir)"; \
+	}
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libdir)/$$f"; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
 clean-noinstLTLIBRARIES:
 	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
 	@list='$(noinst_LTLIBRARIES)'; \
@@ -1310,7 +1381,7 @@ clean-noinstLTLIBRARIES:
 	}
 
 libopts.la: $(libopts_la_OBJECTS) $(libopts_la_DEPENDENCIES) $(EXTRA_libopts_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(LINK)  $(libopts_la_OBJECTS) $(libopts_la_LIBADD) $(LIBS)
+	$(AM_V_CCLD)$(libopts_la_LINK) $(am_libopts_la_rpath) $(libopts_la_OBJECTS) $(libopts_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -1444,6 +1515,9 @@ check: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) check-am
 all-am: Makefile $(LTLIBRARIES)
 installdirs:
+	for dir in "$(DESTDIR)$(libdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
 install: $(BUILT_SOURCES)
 	$(MAKE) $(AM_MAKEFLAGS) install-am
 install-exec: install-exec-am
@@ -1480,8 +1554,8 @@ maintainer-clean-generic:
 	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
 clean: clean-am
 
-clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
-	mostlyclean-am
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	clean-noinstLTLIBRARIES mostlyclean-am
 
 distclean: distclean-am
 	-rm -rf ./$(DEPDIR)
@@ -1507,7 +1581,7 @@ install-dvi: install-dvi-am
 
 install-dvi-am:
 
-install-exec-am:
+install-exec-am: install-libLTLIBRARIES
 
 install-html: install-html-am
 
@@ -1547,26 +1621,30 @@ ps: ps-am
 
 ps-am:
 
-uninstall-am:
+uninstall-am: uninstall-libLTLIBRARIES
 
 .MAKE: all check install install-am install-strip
 
 .PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
-	ctags-am distclean distclean-compile distclean-generic \
-	distclean-libtool distclean-tags distdir dvi dvi-am html \
-	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags tags-am uninstall uninstall-am
+	clean-libLTLIBRARIES clean-libtool clean-noinstLTLIBRARIES \
+	cscopelist-am ctags ctags-am distclean distclean-compile \
+	distclean-generic distclean-libtool distclean-tags distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-libLTLIBRARIES \
+	install-man install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am uninstall-libLTLIBRARIES
 
 .PRECIOUS: Makefile
 
+
+libopts.c:		$(BUILT_SOURCES)
+	@: do-nothing rule to avoid default SCCS get
 @GL_GENERATE_STDNORETURN_H_TRUE@stdnoreturn.h: stdnoreturn.in.h $(top_builddir)/config.status $(_NORETURN_H)
 @GL_GENERATE_STDNORETURN_H_TRUE@	$(AM_V_GEN)rm -f $@-t $@ && \
 @GL_GENERATE_STDNORETURN_H_TRUE@	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
diff --git a/src/libopts/README b/src/libopts/README
index 4bf758d..98e4f3c 100644
--- a/src/libopts/README
+++ b/src/libopts/README
@@ -115,7 +115,7 @@ These macros work as follows:
 
 LICENSING:
 
-This material is Copyright (C) 1992-2014 by Bruce Korb.  You are
+This material is Copyright (C) 1992-2015 by Bruce Korb.  You are
 licensed to use this under the terms of either the GNU Lesser General
 Public License (see: COPYING.lgpl), or, at your option, the modified
 Berkeley Software Distribution License (see: COPYING.mbsd).  Both of
diff --git a/src/libopts/ag-char-map.h b/src/libopts/ag-char-map.h
index d50e665..281badd 100644
--- a/src/libopts/ag-char-map.h
+++ b/src/libopts/ag-char-map.h
@@ -1,6 +1,6 @@
 /*
  *  29 bits for 46 character classifications
- *  generated by char-mapper on 08/30/14 at 10:36:23
+ *  generated by char-mapper on 04/30/15 at 19:55:13
  *
  *  This file contains the character classifications
  *  used by AutoGen and AutoOpts for identifying tokens.
@@ -8,7 +8,7 @@
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
diff --git a/src/libopts/alias.c b/src/libopts/alias.c
index be8c6c6..49e1f1f 100644
--- a/src/libopts/alias.c
+++ b/src/libopts/alias.c
@@ -12,7 +12,7 @@
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
diff --git a/src/libopts/ao-strs.c b/src/libopts/ao-strs.c
index c385a4d..857aa73 100644
--- a/src/libopts/ao-strs.c
+++ b/src/libopts/ao-strs.c
@@ -6,7 +6,7 @@
  * From the definitions    ao-strs.def
  * and the template file   strings
  *
- *  Copyright (C) 2011-2014 Bruce Korb, all rights reserved.
+ *  Copyright (C) 2011-2015 Bruce Korb, all rights reserved.
  *  This is free software. It is licensed for use, modification and
  *  redistribution under the terms of the
  *  Modified (3 clause) Berkeley Software Distribution License
diff --git a/src/libopts/ao-strs.h b/src/libopts/ao-strs.h
index 812186a..864fc48 100644
--- a/src/libopts/ao-strs.h
+++ b/src/libopts/ao-strs.h
@@ -6,7 +6,7 @@
  * From the definitions    ao-strs.def
  * and the template file   strings
  *
- *  Copyright (C) 2011-2014 Bruce Korb, all rights reserved.
+ *  Copyright (C) 2011-2015 Bruce Korb, all rights reserved.
  *  This is free software. It is licensed for use, modification and
  *  redistribution under the terms of the
  *  Modified (3 clause) Berkeley Software Distribution License
diff --git a/src/libopts/autoopts.c b/src/libopts/autoopts.c
index a519318..4b15aca 100644
--- a/src/libopts/autoopts.c
+++ b/src/libopts/autoopts.c
@@ -13,7 +13,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -299,9 +299,9 @@ regular_opts(tOptions * opts)
  *
  * what: this is the main option processing routine
  *
- * arg:  + tOptions* + opts  + program options descriptor +
- * arg:  + int       + a_ct  + program arg count  +
- * arg:  + char**    + a_v   + program arg vector +
+ * arg:  + tOptions * + opts  + program options descriptor +
+ * arg:  + int        + a_ct  + program arg count  +
+ * arg:  + char **    + a_v   + program arg vector +
  *
  * ret_type:  int
  * ret_desc:  the count of the arguments processed
diff --git a/src/libopts/autoopts.h b/src/libopts/autoopts.h
index 27a907c..6f75f9e 100644
--- a/src/libopts/autoopts.h
+++ b/src/libopts/autoopts.h
@@ -11,7 +11,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -41,7 +41,7 @@
 #  ifdef PATH_MAX
 #    define AG_PATH_MAX         ((size_t)PATH_MAX)
 #  else
-#    define AG_PATH_MAX         4096
+#    define AG_PATH_MAX         ((size_t)4096)
 #  endif
 #else
 #  if defined(PATH_MAX) && (PATH_MAX > MAXPATHLEN)
@@ -107,7 +107,7 @@
  *  Coercive cast.  Compel an address to be interpreted as the type
  *  of the first argument.  No complaints, just do it.
  */
-#define C(_t,_p)  ((_t)(void *)(_p))
+#define C(_t,_p)  ((_t)VOIDP(_p))
 #endif
 
 /* The __attribute__((__warn_unused_result__)) feature
@@ -256,10 +256,10 @@ typedef struct {
     char const * pzTime;
 } arg_types_t;
 
-#define AGALOC(c, w)          ao_malloc((size_t)c)
-#define AGREALOC(p, c, w)     ao_realloc((void*)p, (size_t)c)
-#define AGFREE(_p)            free((void *)_p)
-#define AGDUPSTR(p, s, w)     (p = ao_strdup(s))
+#define AGALOC(_c, _w)        ao_malloc((size_t)_c)
+#define AGREALOC(_p, _c, _w)  ao_realloc(VOIDP(_p), (size_t)_c)
+#define AGFREE(_p)            free(VOIDP(_p))
+#define AGDUPSTR(_p, _s, _w)  (_p = ao_strdup(_s))
 
 static void *
 ao_malloc(size_t sz);
@@ -267,10 +267,10 @@ ao_malloc(size_t sz);
 static void *
 ao_realloc(void *p, size_t sz);
 
-#define ao_free(_p) free((void *)_p)
+#define ao_free(_p) free(VOIDP(_p))
 
 static char *
-ao_strdup(char const *str);
+ao_strdup(char const * str);
 
 /**
  *  DO option handling?
@@ -369,7 +369,7 @@ ao_strdup(char const *str);
 #endif
 
 #ifndef MAP_FAILED
-#  define  MAP_FAILED           ((void*)-1)
+#  define  MAP_FAILED           VOIDP(-1)
 #endif
 
 #ifndef  _SC_PAGESIZE
@@ -379,8 +379,8 @@ ao_strdup(char const *str);
 #endif
 
 #ifndef HAVE_STRCHR
-extern char* strchr(char const *s, int c);
-extern char* strrchr(char const *s, int c);
+extern char * strchr(char const * s, int c);
+extern char * strrchr(char const * s, int c);
 #endif
 
 /**
diff --git a/src/libopts/autoopts/options.h b/src/libopts/autoopts/options.h
index 6a5c9e5..0601d0f 100644
--- a/src/libopts/autoopts/options.h
+++ b/src/libopts/autoopts/options.h
@@ -9,11 +9,11 @@
  *  This file defines all the global structures and special values
  *  used in the automated option processing library.
  *
- *  Automated Options Copyright (C) 1992-2014 by Bruce Korb
+ *  Automated Options Copyright (C) 1992-2015 by Bruce Korb
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -82,6 +82,14 @@
  */
 #define AO_EXIT_REQ_USAGE 10064
 
+#undef  VOIDP
+/**
+ * Coerce a value into a void pointer with no const or volatile attributes.
+ * Somewhere along the line, the above set of includes need to set up
+ * the "uintptr_t" type.
+ */
+#define VOIDP(_a)  ((void *)(uintptr_t)(_a))
+
 /**
  *  PUBLIC DEFINES
  *
@@ -90,7 +98,7 @@
  *  to an option descriptor must be obtained.  There are two ways:
  *
  *  1. inside an option processing procedure, it is the second argument,
- *     conventionally "tOptDesc* pOD".
+ *     conventionally "tOptDesc * pOD".
  *
  *  2. Outside of an option procedure (or to reference a different option
  *     descriptor), use either "&DESC( opt_name )" or "&pfx_DESC( opt_name )".
@@ -101,15 +109,15 @@
  * @{
  */
 /// autoopts structure version
-#define OPTIONS_STRUCT_VERSION      167936
+#define OPTIONS_STRUCT_VERSION      167937
 /// autoopts structure version string
-#define OPTIONS_VERSION_STRING      "41:0:16"
+#define OPTIONS_VERSION_STRING      "41:1:16"
 /// minimum version the autoopts library supports
 #define OPTIONS_MINIMUM_VERSION     102400
 /// minimum version the autoopts library supports as a string
 #define OPTIONS_MIN_VER_STRING      "25:0:0"
 /// the display version of the autoopts library, as a string
-#define OPTIONS_DOTTED_VERSION      "41.0"
+#define OPTIONS_DOTTED_VERSION      "41.1"
 /// convert a version/release number pair to an integer value
 #define OPTIONS_VER_TO_NUM(_v, _r)  (((_v) * 4096) + (_r))
 /// @}
@@ -147,7 +155,7 @@ typedef struct optionValue {
         unsigned int    boolVal;        ///< OPARG_TYPE_BOOLEAN
         unsigned long   setVal;         ///< OPARG_TYPE_MEMBERSHIP
         long            longVal;        ///< OPARG_TYPE_NUMERIC
-        void*           nestVal;        ///< OPARG_TYPE_HIERARCHY
+        void *          nestVal;        ///< OPARG_TYPE_HIERARCHY
     } v;
 } tOptionValue;
 
@@ -445,7 +453,7 @@ typedef tOptProc * tpOptProc;
  *  with the "exitCode" argument passed to it.
  */
 // coverity[+kill]
-typedef void (tUsageProc)(tOptions* pOpts, int exitCode);
+typedef void (tUsageProc)(tOptions * pOpts, int exitCode);
 
 /**
  * a pointer to a procedure that prints usage and exits.
@@ -690,7 +698,7 @@ struct options {
  */
 typedef struct {
     unsigned long   tkn_ct;      ///< number of tokens found
-    unsigned char*  tkn_list[1]; ///< array of pointers to tokens
+    unsigned char * tkn_list[1]; ///< array of pointers to tokens
 } token_list_t;
 
 /*
@@ -728,7 +736,7 @@ typedef struct {
 /**
  * mmap result wrapper that yields "true" when mmap has failed.
  */
-#define TEXT_MMAP_FAILED_ADDR(a)  ((void*)(a) ==  (void*)MAP_FAILED)
+#define TEXT_MMAP_FAILED_ADDR(a)  (VOIDP(a) == VOIDP(MAP_FAILED))
 
 #ifdef  __cplusplus
 #define CPLUSPLUS_OPENER extern "C" {
@@ -779,9 +787,9 @@ CPLUSPLUS_OPENER
  *
  * @param string       string to be tokenized
  *
- * @return token_list_t* - pointer to a structure that lists each token
+ * @return token_list_t * - pointer to a structure that lists each token
  */
-extern token_list_t* ao_string_tokenize(char const*);
+extern token_list_t * ao_string_tokenize(char const *);
 
 
 /**
@@ -797,9 +805,9 @@ extern token_list_t* ao_string_tokenize(char const*);
  *
  * @param fname        the file to load
  *
- * @return const tOptionValue* - An allocated, compound value structure
+ * @return const tOptionValue * - An allocated, compound value structure
  */
-extern const tOptionValue* configFileLoad(char const*);
+extern const tOptionValue * configFileLoad(char const *);
 
 
 /**
@@ -827,7 +835,7 @@ extern const tOptionValue* configFileLoad(char const*);
  *
  * @return int - 0 -> SUCCESS, -1 -> FAILURE
  */
-extern int optionFileLoad(tOptions*, char const*);
+extern int optionFileLoad(tOptions *, char const *);
 
 
 /**
@@ -842,9 +850,9 @@ extern int optionFileLoad(tOptions*, char const*);
  * @param name         name of value to find
  * @param value        the matching value
  *
- * @return const tOptionValue* - a compound value structure
+ * @return const tOptionValue * - a compound value structure
  */
-extern const tOptionValue* optionFindNextValue(const tOptDesc*, const tOptionValue*, char const*, char const*);
+extern const tOptionValue * optionFindNextValue(const tOptDesc *, const tOptionValue *, char const *, char const *);
 
 
 /**
@@ -857,9 +865,9 @@ extern const tOptionValue* optionFindNextValue(const tOptDesc*, const tOptionVal
  * @param name         name of value to find
  * @param val          the matching value
  *
- * @return const tOptionValue* - a compound value structure
+ * @return const tOptionValue * - a compound value structure
  */
-extern const tOptionValue* optionFindValue(const tOptDesc*, char const*, char const*);
+extern const tOptionValue * optionFindValue(const tOptDesc *, char const *, char const *);
 
 
 /**
@@ -870,7 +878,7 @@ extern const tOptionValue* optionFindValue(const tOptDesc*, char const*, char co
  *
  * @param pOpts        program options descriptor
  */
-extern void optionFree(tOptions*);
+extern void optionFree(tOptions *);
 
 
 /**
@@ -886,9 +894,9 @@ extern void optionFree(tOptions*);
  * @param pOptValue    a hierarchcal value
  * @param valueName    name of value to get
  *
- * @return const tOptionValue* - a compound value structure
+ * @return const tOptionValue * - a compound value structure
  */
-extern const tOptionValue* optionGetValue(const tOptionValue*, char const*);
+extern const tOptionValue * optionGetValue(const tOptionValue *, char const *);
 
 
 /**
@@ -911,7 +919,7 @@ extern const tOptionValue* optionGetValue(const tOptionValue*, char const*);
  * @param opts         program options descriptor
  * @param line         NUL-terminated text
  */
-extern void optionLoadLine(tOptions*, char const*);
+extern void optionLoadLine(tOptions *, char const *);
 
 
 /**
@@ -922,9 +930,9 @@ extern void optionLoadLine(tOptions*, char const*);
  *
  * @param od           the set membership option description
  *
- * @return char* - the names of the set bits
+ * @return char * - the names of the set bits
  */
-extern char* optionMemberList(tOptDesc *);
+extern char * optionMemberList(tOptDesc *);
 
 
 /**
@@ -939,9 +947,9 @@ extern char* optionMemberList(tOptDesc *);
  * @param pOptValue    a hierarchcal list value
  * @param pOldValue    a value from this list
  *
- * @return const tOptionValue* - a compound value structure
+ * @return const tOptionValue * - a compound value structure
  */
-extern const tOptionValue* optionNextValue(const tOptionValue*, const tOptionValue*);
+extern const tOptionValue * optionNextValue(const tOptionValue *, const tOptionValue *);
 
 
 /**
@@ -954,7 +962,7 @@ extern const tOptionValue* optionNextValue(const tOptionValue*, const tOptionVal
  * @param pOpts        program options descriptor
  * @param ex_code      exit code for calling exit(3)
  */
-extern void optionOnlyUsage(tOptions*, int);
+extern void optionOnlyUsage(tOptions *, int);
 
 
 /**
@@ -965,7 +973,7 @@ extern void optionOnlyUsage(tOptions*, int);
  * @param opts         program options descriptor
  * @param od           the descriptor for this arg
  */
-extern void optionPrintVersion(tOptions*, tOptDesc*);
+extern void optionPrintVersion(tOptions *, tOptDesc *);
 
 
 /**
@@ -979,7 +987,7 @@ extern void optionPrintVersion(tOptions*, tOptDesc*);
  * @param opts         program options descriptor
  * @param od           the descriptor for this arg
  */
-extern void optionPrintVersionAndReturn(tOptions*, tOptDesc*);
+extern void optionPrintVersionAndReturn(tOptions *, tOptDesc *);
 
 
 /**
@@ -1007,7 +1015,7 @@ extern void optionPrintVersionAndReturn(tOptions*, tOptDesc*);
  *
  * @return int - the count of the arguments processed
  */
-extern int optionProcess(tOptions*, int, char**);
+extern int optionProcess(tOptions *, int, char **);
 
 
 /**
@@ -1022,7 +1030,7 @@ extern int optionProcess(tOptions*, int, char**);
  *
  * @param pOpts        program options descriptor
  */
-extern void optionRestore(tOptions*);
+extern void optionRestore(tOptions *);
 
 
 /**
@@ -1045,7 +1053,7 @@ extern void optionRestore(tOptions*);
  *
  * @param opts         program options descriptor
  */
-extern void optionSaveFile(tOptions*);
+extern void optionSaveFile(tOptions *);
 
 
 /**
@@ -1065,7 +1073,7 @@ extern void optionSaveFile(tOptions*);
  *
  * @param pOpts        program options descriptor
  */
-extern void optionSaveState(tOptions*);
+extern void optionSaveState(tOptions *);
 
 
 /**
@@ -1086,9 +1094,9 @@ extern void optionUnloadNested(tOptionValue const *);
  *  Returns the full version string compiled into the library.
  *  The returned string cannot be modified.
  *
- * @return char const* - the version string in constant memory
+ * @return char const * - the version string in constant memory
  */
-extern char const* optionVersion(void);
+extern char const * optionVersion(void);
 
 
 /**
@@ -1101,7 +1109,7 @@ extern char const* optionVersion(void);
  *
  * @param ch_list      characters to equivalence
  */
-extern void strequate(char const*);
+extern void strequate(char const *);
 
 
 /**
@@ -1118,7 +1126,7 @@ extern void strequate(char const*);
  *
  * @return int - the difference between two differing characters
  */
-extern int streqvcmp(char const*, char const*);
+extern int streqvcmp(char const *, char const *);
 
 
 /**
@@ -1163,7 +1171,7 @@ extern void streqvmap(char, char, int);
  *
  * @return int - the difference between two differing characters
  */
-extern int strneqvcmp(char const*, char const*, int);
+extern int strneqvcmp(char const *, char const *, int);
 
 
 /**
@@ -1179,68 +1187,68 @@ extern int strneqvcmp(char const*, char const*, int);
  * @param dest         output string
  * @param src          input string
  */
-extern void strtransform(char*, char const*);
+extern void strtransform(char *, char const *);
 
 /*  AutoOpts PRIVATE FUNCTIONS:  */
 tOptProc optionStackArg, optionUnstackArg, optionBooleanVal, optionNumericVal;
 
-extern char* ao_string_cook(char*, int*);
+extern char * ao_string_cook(char *, int *);
 
-extern unsigned int ao_string_cook_escape_char(char const*, char*, unsigned int);
+extern unsigned int ao_string_cook_escape_char(char const *, char *, unsigned int);
 
-extern void genshelloptUsage(tOptions*, int);
+extern void genshelloptUsage(tOptions *, int);
 
 extern int optionAlias(tOptions *, tOptDesc *, unsigned int);
 
-extern void optionBooleanVal(tOptions*, tOptDesc*);
+extern void optionBooleanVal(tOptions *, tOptDesc *);
 
-extern uintptr_t optionEnumerationVal(tOptions*, tOptDesc*, char const * const *, unsigned int);
+extern uintptr_t optionEnumerationVal(tOptions *, tOptDesc *, char const * const *, unsigned int);
 
-extern void optionFileCheck(tOptions*, tOptDesc*, teOptFileType, tuFileMode);
+extern void optionFileCheck(tOptions *, tOptDesc *, teOptFileType, tuFileMode);
 
-extern char const * optionKeywordName(tOptDesc*, unsigned int);
+extern char const * optionKeywordName(tOptDesc *, unsigned int);
 
-extern void optionLoadOpt(tOptions*, tOptDesc*);
+extern void optionLoadOpt(tOptions *, tOptDesc *);
 
-extern bool optionMakePath(char*, int, char const*, char const*);
+extern bool optionMakePath(char *, int, char const *, char const *);
 
-extern void optionNestedVal(tOptions*, tOptDesc*);
+extern void optionNestedVal(tOptions *, tOptDesc *);
 
-extern void optionNumericVal(tOptions*, tOptDesc*);
+extern void optionNumericVal(tOptions *, tOptDesc *);
 
 extern void optionPagedUsage(tOptions *, tOptDesc *);
 
-extern void optionParseShell(tOptions*);
+extern void optionParseShell(tOptions *);
 
 extern void optionPrintParagraphs(char const *, bool, FILE *);
 
-extern void optionPutShell(tOptions*);
+extern void optionPutShell(tOptions *);
 
 extern char const * optionQuoteString(char const *, char const *);
 
-extern void optionResetOpt(tOptions*, tOptDesc*);
+extern void optionResetOpt(tOptions *, tOptDesc *);
 
-extern void optionSetMembers(tOptions*, tOptDesc*, char const * const *, unsigned int);
+extern void optionSetMembers(tOptions *, tOptDesc *, char const * const *, unsigned int);
 
-extern void optionShowRange(tOptions*, tOptDesc*, void *, int);
+extern void optionShowRange(tOptions *, tOptDesc *, void *, int);
 
-extern void optionStackArg(tOptions*, tOptDesc*);
+extern void optionStackArg(tOptions *, tOptDesc *);
 
-extern void optionTimeDate(tOptions*, tOptDesc*);
+extern void optionTimeDate(tOptions *, tOptDesc *);
 
-extern void optionTimeVal(tOptions*, tOptDesc*);
+extern void optionTimeVal(tOptions *, tOptDesc *);
 
-extern void optionUnstackArg(tOptions*, tOptDesc*);
+extern void optionUnstackArg(tOptions *, tOptDesc *);
 
-extern void optionUsage(tOptions*, int);
+extern void optionUsage(tOptions *, int);
 
 extern void optionVendorOption(tOptions *, tOptDesc *);
 
-extern void optionVersionStderr(tOptions*, tOptDesc*);
+extern void optionVersionStderr(tOptions *, tOptDesc *);
 
-extern void* text_mmap(char const*, int, int, tmap_info_t*);
+extern void * text_mmap(char const *, int, int, tmap_info_t *);
 
-extern int text_munmap(tmap_info_t*);
+extern int text_munmap(tmap_info_t *);
 
 CPLUSPLUS_CLOSER
 #endif /* AUTOOPTS_OPTIONS_H_GUARD */
diff --git a/src/libopts/autoopts/project.h b/src/libopts/autoopts/project.h
index c61a6ca..1e7f156 100644
--- a/src/libopts/autoopts/project.h
+++ b/src/libopts/autoopts/project.h
@@ -4,7 +4,7 @@
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
diff --git a/src/libopts/autoopts/usage-txt.h b/src/libopts/autoopts/usage-txt.h
index 0307a31..f5831e6 100644
--- a/src/libopts/autoopts/usage-txt.h
+++ b/src/libopts/autoopts/usage-txt.h
@@ -8,7 +8,7 @@
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -368,19 +368,19 @@ static void dummy_func(void) {
   puts(_("allocation of %d bytes failed\n"));
 #line 53 "../init.c"
   puts(_("AutoOpts function called without option descriptor\n"));
-#line 90 "../init.c"
+#line 86 "../init.c"
   puts(_("\tThis exceeds the compiled library version:  "));
-#line 88 "../init.c"
+#line 84 "../init.c"
   puts(_("Automated Options Processing Error!\n"
        "\t%s called AutoOpts function with structure version %d:%d:%d.\n"));
 #line 80 "../autoopts.c"
   puts(_("realloc of %d bytes at 0x%p failed\n"));
-#line 92 "../init.c"
+#line 88 "../init.c"
   puts(_("\tThis is less than the minimum library version:  "));
 #line 121 "../version.c"
   puts(_("Automated Options version %s\n"
        "\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n"));
-#line 82 "../makeshell.c"
+#line 87 "../makeshell.c"
   puts(_("(AutoOpts bug):  %s.\n"));
 #line 90 "../reset.c"
   puts(_("optionResetOpt() called, but reset-option not configured"));
@@ -404,9 +404,9 @@ static void dummy_func(void) {
   puts(_("%s: Command line arguments required\n"));
 #line 43 "../alias.c"
   puts(_("%d %s%s options allowed\n"));
-#line 89 "../makeshell.c"
+#line 94 "../makeshell.c"
   puts(_("%s error %d (%s) calling %s for '%s'\n"));
-#line 301 "../makeshell.c"
+#line 306 "../makeshell.c"
   puts(_("interprocess pipe"));
 #line 168 "../version.c"
   puts(_("error: version option argument '%c' invalid.  Use:\n"
@@ -484,9 +484,9 @@ static void dummy_func(void) {
   puts(_("Try '%s %s' for more information.\n"));
 #line 45 "../alias.c"
   puts(_("one %s%s option allowed\n"));
-#line 203 "../makeshell.c"
+#line 208 "../makeshell.c"
   puts(_("standard output"));
-#line 938 "../makeshell.c"
+#line 943 "../makeshell.c"
   puts(_("standard output"));
 #line 274 "../usage.c"
   puts(_("standard output"));
@@ -504,9 +504,9 @@ static void dummy_func(void) {
   puts(_("standard error"));
 #line 175 "../version.c"
   puts(_("standard error"));
-#line 203 "../makeshell.c"
+#line 208 "../makeshell.c"
   puts(_("write"));
-#line 938 "../makeshell.c"
+#line 943 "../makeshell.c"
   puts(_("write"));
 #line 273 "../usage.c"
   puts(_("write"));
@@ -558,7 +558,7 @@ static void dummy_func(void) {
 #line 380 "../usage.c"
   puts(_("Options are specified by doubled hyphens and their name or by a single\n"
        "hyphen and the flag character.\n"));
-#line 916 "../makeshell.c"
+#line 921 "../makeshell.c"
   puts(_("\n"
        "= = = = = = = =\n\n"
        "This incarnation of genshell will produce\n"
diff --git a/src/libopts/boolean.c b/src/libopts/boolean.c
index e83e518..2bea8e7 100644
--- a/src/libopts/boolean.c
+++ b/src/libopts/boolean.c
@@ -13,7 +13,7 @@
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -36,8 +36,8 @@
  * private:
  *
  * what:  Decipher a boolean value
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od  + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od  + the descriptor for this arg +
  *
  * doc:
  *  Decipher a true or false value for a boolean valued option argument.
@@ -47,8 +47,8 @@
 void
 optionBooleanVal(tOptions * opts, tOptDesc * od)
 {
-    char* pz;
-    bool  res = true;
+    char * pz;
+    bool   res = true;
 
     if (INQUERY_CALL(opts, od))
         return;
diff --git a/src/libopts/check.c b/src/libopts/check.c
index 9b221a1..eff8ec0 100644
--- a/src/libopts/check.c
+++ b/src/libopts/check.c
@@ -9,7 +9,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
diff --git a/src/libopts/compat/compat.h b/src/libopts/compat/compat.h
index 69206a3..561d55d 100644
--- a/src/libopts/compat/compat.h
+++ b/src/libopts/compat/compat.h
@@ -3,7 +3,7 @@
  *  compat.h is free software.
  *  This file is part of AutoGen and AutoOpts.
  *
- *  AutoGen Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoGen Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
diff --git a/src/libopts/compat/pathfind.c b/src/libopts/compat/pathfind.c
index 6554533..5c477ca 100644
--- a/src/libopts/compat/pathfind.c
+++ b/src/libopts/compat/pathfind.c
@@ -23,9 +23,9 @@ pathfind( char const * path,
 }
 #else
 
-static char* make_absolute( char const *string, char const *dot_path );
-static char* canonicalize_pathname( char *path );
-static char* extract_colon_unit( char* dir, char const *string, int *p_index );
+static char * make_absolute(char const * string, char const * dot_path);
+static char * canonicalize_pathname(char * path);
+static char * extract_colon_unit(char * dir, char const * string, int * p_index);
 
 /**
  * local implementation of pathfind.
@@ -52,8 +52,8 @@ pathfind( char const * path,
      *  FOR each non-null entry in the colon-separated path, DO ...
      */
     for (;;) {
-        DIR*  dirP;
-        char* colon_unit = extract_colon_unit( zPath, path, &p_index );
+        DIR  * dirP;
+        char * colon_unit = extract_colon_unit( zPath, path, &p_index );
 
         if (colon_unit == NULL)
             break;
@@ -69,7 +69,7 @@ pathfind( char const * path,
         for (;;) {
             struct dirent *entP = readdir( dirP );
 
-            if (entP == (struct dirent*)NULL)
+            if (entP == (struct dirent *)NULL)
                 break;
 
             /*
@@ -107,10 +107,10 @@ pathfind( char const * path,
  * DOT_PATH contains the symbolic location of  `.'.  This always returns
  * a new string, even if STRING was an absolute pathname to begin with.
  */
-static char*
-make_absolute( char const *string, char const *dot_path )
+static char *
+make_absolute( char const * string, char const * dot_path )
 {
-    char *result;
+    char * result;
     int result_len;
 
     if (!dot_path || *string == '/') {
@@ -147,7 +147,7 @@ make_absolute( char const *string, char const *dot_path )
  *    Non-leading `../'s and trailing `..'s are handled by removing
  *                    portions of the path.
  */
-static char*
+static char *
 canonicalize_pathname( char *path )
 {
     int i, start;
@@ -231,8 +231,8 @@ canonicalize_pathname( char *path )
  * return the next one  pointed to by (P_INDEX), or NULL if there are no
  * more.  Advance (P_INDEX) to the character after the colon.
  */
-static char*
-extract_colon_unit( char* pzDir, char const *string, int *p_index )
+static char *
+extract_colon_unit(char * pzDir, char const * string, int * p_index)
 {
     char * pzDest = pzDir;
     int    ix     = *p_index;
diff --git a/src/libopts/compat/windows-config.h b/src/libopts/compat/windows-config.h
index 78f3202..fb4e048 100644
--- a/src/libopts/compat/windows-config.h
+++ b/src/libopts/compat/windows-config.h
@@ -9,7 +9,7 @@
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
diff --git a/src/libopts/configfile.c b/src/libopts/configfile.c
index d4bc4fe..03156ca 100644
--- a/src/libopts/configfile.c
+++ b/src/libopts/configfile.c
@@ -9,7 +9,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -33,7 +33,7 @@ static void
 file_preset(tOptions * opts, char const * fname, int dir);
 
 static char *
-handle_comment(char* txt);
+handle_comment(char * txt);
 
 static char *
 handle_cfg(tOptions * opts, tOptState * ost, char * txt, int dir);
@@ -87,9 +87,9 @@ skip_unkn(char const * txt)
 /*=export_func  configFileLoad
  *
  * what:  parse a configuration file
- * arg:   + char const*     + fname + the file to load +
+ * arg:   + char const * + fname + the file to load +
  *
- * ret_type:  const tOptionValue*
+ * ret_type:  const tOptionValue *
  * ret_desc:  An allocated, compound value structure
  *
  * doc:
@@ -146,11 +146,11 @@ configFileLoad(char const * fname)
 /*=export_func  optionFindValue
  *
  * what:  find a hierarcicaly valued option instance
- * arg:   + const tOptDesc* + odesc + an option with a nested arg type +
- * arg:   + char const*     + name  + name of value to find +
- * arg:   + char const*     + val   + the matching value    +
+ * arg:   + const tOptDesc * + odesc + an option with a nested arg type +
+ * arg:   + char const *     + name  + name of value to find +
+ * arg:   + char const *     + val   + the matching value    +
  *
- * ret_type:  const tOptionValue*
+ * ret_type:  const tOptionValue *
  * ret_desc:  a compound value structure
  *
  * doc:
@@ -182,9 +182,9 @@ optionFindValue(const tOptDesc * odesc, char const * name, char const * val)
     }
 
     else do {
-        tArgList* argl  = odesc->optCookie;
-        int       argct = argl->useCt;
-        void **   poptv = (void**)(argl->apzArgs);
+        tArgList * argl  = odesc->optCookie;
+        int        argct = argl->useCt;
+        void **    poptv = (void **)(argl->apzArgs);
 
         if (argct == 0) {
             errno = ENOENT;
@@ -192,7 +192,7 @@ optionFindValue(const tOptDesc * odesc, char const * name, char const * val)
         }
 
         if (name == NULL) {
-            res = (tOptionValue*)*poptv;
+            res = (tOptionValue *)*poptv;
             break;
         }
 
@@ -221,12 +221,12 @@ optionFindValue(const tOptDesc * odesc, char const * name, char const * val)
  * FIXME: the handling of 'pzName' and 'pzVal' is just wrong.
  *
  * what:  find a hierarcicaly valued option instance
- * arg:   + const tOptDesc* + odesc + an option with a nested arg type +
- * arg:   + const tOptionValue* + pPrevVal + the last entry +
- * arg:   + char const*     + name     + name of value to find +
- * arg:   + char const*     + value    + the matching value    +
+ * arg:   + const tOptDesc * + odesc + an option with a nested arg type +
+ * arg:   + const tOptionValue * + pPrevVal + the last entry +
+ * arg:   + char const *     + name     + name of value to find +
+ * arg:   + char const *     + value    + the matching value    +
  *
- * ret_type:  const tOptionValue*
+ * ret_type:  const tOptionValue *
  * ret_desc:  a compound value structure
  *
  * doc:
@@ -249,7 +249,7 @@ optionFindNextValue(const tOptDesc * odesc, const tOptionValue * pPrevVal,
                     char const * pzName, char const * pzVal)
 {
     bool old_found = false;
-    tOptionValue* res = NULL;
+    tOptionValue * res = NULL;
 
     (void)pzName;
     (void)pzVal;
@@ -264,12 +264,12 @@ optionFindNextValue(const tOptDesc * odesc, const tOptionValue * pPrevVal,
     }
 
     else do {
-        tArgList* argl = odesc->optCookie;
-        int    ct   = argl->useCt;
-        void** poptv = (void**)argl->apzArgs;
+        tArgList * argl = odesc->optCookie;
+        int        ct   = argl->useCt;
+        void **   poptv = (void **)argl->apzArgs;
 
         while (--ct >= 0) {
-            tOptionValue* pOV = *(poptv++);
+            tOptionValue * pOV = *(poptv++);
             if (old_found) {
                 res = pOV;
                 break;
@@ -288,10 +288,10 @@ optionFindNextValue(const tOptDesc * odesc, const tOptionValue * pPrevVal,
 /*=export_func  optionGetValue
  *
  * what:  get a specific value from a hierarcical list
- * arg:   + const tOptionValue* + pOptValue + a hierarchcal value +
- * arg:   + char const*   + valueName + name of value to get +
+ * arg:   + const tOptionValue * + pOptValue + a hierarchcal value +
+ * arg:   + char const *         + valueName + name of value to get +
  *
- * ret_type:  const tOptionValue*
+ * ret_type:  const tOptionValue *
  * ret_desc:  a compound value structure
  *
  * doc:
@@ -326,10 +326,10 @@ optionGetValue(tOptionValue const * oov, char const * vname)
 
     if (arg_list->useCt > 0) {
         int     ct     = arg_list->useCt;
-        void ** ovlist = (void**)(arg_list->apzArgs);
+        void ** ovlist = (void **)(arg_list->apzArgs);
 
         if (vname == NULL) {
-            res = (tOptionValue*)*ovlist;
+            res = (tOptionValue *)*ovlist;
 
         } else do {
             tOptionValue * opt_val = *(ovlist++);
@@ -347,10 +347,10 @@ optionGetValue(tOptionValue const * oov, char const * vname)
 /*=export_func  optionNextValue
  *
  * what:  get the next value from a hierarchical list
- * arg:   + const tOptionValue* + pOptValue + a hierarchcal list value +
- * arg:   + const tOptionValue* + pOldValue + a value from this list   +
+ * arg:   + const tOptionValue * + pOptValue + a hierarchcal list value +
+ * arg:   + const tOptionValue * + pOldValue + a value from this list   +
  *
- * ret_type:  const tOptionValue*
+ * ret_type:  const tOptionValue *
  * ret_desc:  a compound value structure
  *
  * doc:
@@ -385,7 +385,7 @@ optionNextValue(tOptionValue const * ov_list,tOptionValue const * oov )
     arg_list = ov_list->v.nestVal;
     {
         int     ct    = arg_list->useCt;
-        void ** o_list = (void**)(arg_list->apzArgs);
+        void ** o_list = (void **)(arg_list->apzArgs);
 
         while (ct-- > 0) {
             tOptionValue * nov = *(o_list++);
@@ -395,7 +395,7 @@ optionNextValue(tOptionValue const * ov_list,tOptionValue const * oov )
 
                 } else {
                     err = 0;
-                    res = (tOptionValue*)*o_list;
+                    res = (tOptionValue *)*o_list;
                 }
                 break;
             }
@@ -498,9 +498,9 @@ file_preset(tOptions * opts, char const * fname, int dir)
  *  but actually I don't care that much.  It ends with "-->".
  */
 static char *
-handle_comment(char* txt)
+handle_comment(char * txt)
 {
-    char* pz = strstr(txt, "-->");
+    char * pz = strstr(txt, "-->");
     if (pz != NULL)
         pz += 3;
     return pz;
@@ -515,8 +515,8 @@ handle_comment(char* txt)
 static char *
 handle_cfg(tOptions * opts, tOptState * ost, char * txt, int dir)
 {
-    char* pzName = txt++;
-    char* pzEnd  = strchr(txt, NL);
+    char * pzName = txt++;
+    char * pzEnd  = strchr(txt, NL);
 
     if (pzEnd == NULL)
         return txt + strlen(txt);
@@ -547,8 +547,8 @@ handle_cfg(tOptions * opts, tOptState * ost, char * txt, int dir)
      *  on to a newline *not* preceded by a backslash.
      */
     if (pzEnd[-1] == '\\') {
-        char* pcD = pzEnd-1;
-        char* pcS = pzEnd;
+        char * pcD = pzEnd-1;
+        char * pcS = pzEnd;
 
         for (;;) {
             char ch = *(pcS++);
@@ -920,9 +920,9 @@ handle_struct(tOptions * opts, tOptState * ost, char * txt, int dir)
     tOptionLoadMode mode = option_load_mode;
     tOptionValue    valu;
 
-    char* pzName = ++txt;
-    char* pzData;
-    char* pcNulPoint;
+    char * pzName = ++txt;
+    char * pzData;
+    char * pcNulPoint;
 
     txt = SPN_VALUE_NAME_CHARS(txt);
     pcNulPoint = txt;
@@ -931,8 +931,8 @@ handle_struct(tOptions * opts, tOptState * ost, char * txt, int dir)
     switch (*txt) {
     case ' ':
     case '\t':
-        txt = (void *)parse_attrs(
-            opts, SPN_WHITESPACE_CHARS(txt), &mode, &valu);
+        txt = VOIDP(parse_attrs(
+            opts, SPN_WHITESPACE_CHARS(txt), &mode, &valu));
         if (txt == NULL)
             return txt;
         if (*txt == '>')
@@ -1096,8 +1096,8 @@ intern_file_load(tOptions * opts)
  *
  * what: Load the locatable config files, in order
  *
- * arg:  + tOptions*   + opts + program options descriptor +
- * arg:  + char const* + prog + program name +
+ * arg:  + tOptions *   + opts + program options descriptor +
+ * arg:  + char const * + prog + program name +
  *
  * ret_type:  int
  * ret_desc:  0 -> SUCCESS, -1 -> FAILURE
@@ -1137,8 +1137,7 @@ optionFileLoad(tOptions * opts, char const * prog)
      * of this pointer to point to writable memory.
      */
     {
-        char const ** pp =
-            (char const **)(void *)&(opts->pzProgName);
+        char const ** pp = VOIDP(&(opts->pzProgName));
         *pp = prog;
     }
 
@@ -1150,8 +1149,8 @@ optionFileLoad(tOptions * opts, char const * prog)
  * private:
  *
  * what:  Load an option rc/ini file
- * arg:   + tOptions* + opts  + program options descriptor +
- * arg:   + tOptDesc* + odesc + the descriptor for this arg +
+ * arg:   + tOptions * + opts  + program options descriptor +
+ * arg:   + tOptDesc * + odesc + the descriptor for this arg +
  *
  * doc:
  *  Processes the options found in the file named with
diff --git a/src/libopts/cook.c b/src/libopts/cook.c
index 952aac9..65260a2 100644
--- a/src/libopts/cook.c
+++ b/src/libopts/cook.c
@@ -10,7 +10,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -38,8 +38,8 @@ contiguous_quote(char ** pps, char * pq, int * lnct_p);
  * private:
  *
  * what:  escape-process a string fragment
- * arg:   + char const*  + pzScan  + points to character after the escape +
- * arg:   + char*        + pRes    + Where to put the result byte +
+ * arg:   + char const * + pzScan  + points to character after the escape +
+ * arg:   + char *       + pRes    + Where to put the result byte +
  * arg:   + unsigned int + nl_ch   + replacement char if scanned char is \n +
  *
  * ret-type: unsigned int
@@ -184,7 +184,7 @@ contiguous_quote(char ** pps, char * pq, int * lnct_p)
 
             case '*':
             {
-                char* p = strstr( ps+2, "*/" );
+                char * p = strstr( ps+2, "*/" );
                 /*
                  *  Skip to terminating star slash
                  */
@@ -218,10 +218,10 @@ contiguous_quote(char ** pps, char * pq, int * lnct_p)
  * private:
  *
  * what:  concatenate and escape-process strings
- * arg:   + char* + pzScan  + The *MODIFIABLE* input buffer +
- * arg:   + int*  + lnct_p  + The (possibly NULL) pointer to a line count +
+ * arg:   + char * + pzScan  + The *MODIFIABLE* input buffer +
+ * arg:   + int *  + lnct_p  + The (possibly NULL) pointer to a line count +
  *
- * ret-type: char*
+ * ret-type: char *
  * ret-desc: The address of the text following the processed strings.
  *           The return value is NULL if the strings are ill-formed.
  *
@@ -245,8 +245,8 @@ ao_string_cook(char * pzScan, int * lnct_p)
      *  It is a quoted string.  Process the escape sequence characters
      *  (in the set "abfnrtv") and make sure we find a closing quote.
      */
-    char* pzD = pzScan++;
-    char* pzS = pzScan;
+    char * pzD = pzScan++;
+    char * pzS = pzScan;
 
     if (lnct_p == NULL)
         lnct_p = &l;
diff --git a/src/libopts/enum.c b/src/libopts/enum.c
index 299ffb1..3345558 100644
--- a/src/libopts/enum.c
+++ b/src/libopts/enum.c
@@ -14,7 +14,7 @@
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -186,14 +186,14 @@ find_name(char const * name, tOptions * pOpts, tOptDesc * pOD,
 {
     /*
      *  Return the matching index as a pointer sized integer.
-     *  The result gets stashed in a char* pointer.
+     *  The result gets stashed in a char * pointer.
      */
     uintptr_t   res = name_ct;
-    size_t      len = strlen((char*)name);
+    size_t      len = strlen((char *)name);
     uintptr_t   idx;
 
     if (IS_DEC_DIGIT_CHAR(*name)) {
-        char * pz = (char *)(void *)name;
+        char * pz = VOIDP(name);
         unsigned long val = strtoul(pz, &pz, 0);
         if ((*pz == NUL) && (val < name_ct))
             return (uintptr_t)val;
@@ -215,7 +215,7 @@ find_name(char const * name, tOptions * pOpts, tOptDesc * pOD,
      *  Multiple partial matches means we have an ambiguous match.
      */
     for (idx = 0; idx < name_ct; idx++) {
-        if (strncmp((char*)paz_names[idx], (char*)name, len) == 0) {
+        if (strncmp((char *)paz_names[idx], (char *)name, len) == 0) {
             if (paz_names[idx][len] == NUL)
                 return idx;  /* full match */
 
@@ -242,7 +242,7 @@ find_name(char const * name, tOptions * pOpts, tOptDesc * pOD,
  * what:  Convert between enumeration values and strings
  * private:
  *
- * arg:   tOptDesc*,     pOD,       enumeration option description
+ * arg:   tOptDesc *,    pOD,       enumeration option description
  * arg:   unsigned int,  enum_val,  the enumeration value to map
  *
  * ret_type:  char const *
@@ -265,8 +265,8 @@ optionKeywordName(tOptDesc * pOD, unsigned int enum_val)
  * what:  Convert from a string to an enumeration value
  * private:
  *
- * arg:   tOptions*,     pOpts,     the program options descriptor
- * arg:   tOptDesc*,     pOD,       enumeration option description
+ * arg:   tOptions *,    pOpts,     the program options descriptor
+ * arg:   tOptDesc *,    pOD,       enumeration option description
  * arg:   char const * const *,  paz_names, list of enumeration names
  * arg:   unsigned int,  name_ct,   number of names in list
  *
@@ -509,7 +509,7 @@ find_member_bit(tOptions * opts, tOptDesc * od, char const * pz, int len,
  *
  * arg:   tOptDesc *,  od,   the set membership option description
  *
- * ret_type: char*
+ * ret_type: char *
  * ret_desc: the names of the set bits
  *
  * doc:   This converts the OPT_VALUE_name mask value to a allocated string.
@@ -521,7 +521,7 @@ optionMemberList(tOptDesc * od)
     uintptr_t    sv = od->optArg.argIntptr;
     char * res;
     (*(od->pOptProc))(OPTPROC_RETURN_VALNAME, od);
-    res = (void *)od->optArg.argString;
+    res = VOIDP(od->optArg.argString);
     od->optArg.argIntptr = sv;
     return res;
 }
@@ -530,8 +530,8 @@ optionMemberList(tOptDesc * od)
  * what:  Convert between bit flag values and strings
  * private:
  *
- * arg:   tOptions*,     opts,     the program options descriptor
- * arg:   tOptDesc*,     od,       the set membership option description
+ * arg:   tOptions *,     opts,     the program options descriptor
+ * arg:   tOptDesc *,     od,       the set membership option description
  * arg:   char const * const *,
  *                       nm_list,  list of enumeration names
  * arg:   unsigned int,  nm_ct,    number of names in list
@@ -634,12 +634,12 @@ optionSetMembers(tOptions * opts, tOptDesc * od,
         if (nm_ct < (8 * sizeof(uintptr_t)))
             res &= (1UL << nm_ct) - 1UL;
 
-        od->optCookie = (void *)res;
+        od->optCookie = VOIDP(res);
     }
     return;
 
 fail_return:
-    od->optCookie = (void *)0;
+    od->optCookie = VOIDP(0);
 }
 
 /** @}
diff --git a/src/libopts/env.c b/src/libopts/env.c
index 7b6615e..36ae2e5 100644
--- a/src/libopts/env.c
+++ b/src/libopts/env.c
@@ -13,7 +13,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -48,7 +48,7 @@ LOCAL void
 doPrognameEnv(tOptions * pOpts, teEnvPresetType type)
 {
     char const *        env_opts = getenv(pOpts->pzPROGNAME);
-    token_list_t*       pTL;
+    token_list_t *      pTL;
     int                 sv_argc;
     proc_state_mask_t   sv_flag;
     char **             sv_argv;
@@ -82,7 +82,7 @@ doPrognameEnv(tOptions * pOpts, teEnvPresetType type)
      */
     {
         uintptr_t v = (uintptr_t)(pTL->tkn_list);
-        pOpts->origArgVect = (void *)(v - sizeof(char *));
+        pOpts->origArgVect = VOIDP(v - sizeof(char *));
     }
     pOpts->origArgCt   = (unsigned int)pTL->tkn_ct   + 1;
     pOpts->fOptSet    &= ~OPTPROC_ERRSTOP;
@@ -192,7 +192,7 @@ env_presets(tOptions * pOpts, teEnvPresetType type)
 {
     int        ct;
     tOptState  st;
-    char*      pzFlagName;
+    char *     pzFlagName;
     size_t     spaceLeft;
     char       zEnvName[ AO_NAME_SIZE ];
 
diff --git a/src/libopts/file.c b/src/libopts/file.c
index ec740c5..7d92875 100644
--- a/src/libopts/file.c
+++ b/src/libopts/file.c
@@ -10,7 +10,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -107,7 +107,7 @@ open_file_fd(tOptions * pOpts, tOptDesc * pOD, tuFileMode mode)
         /* NOTREACHED */
 
     if ((pOD->fOptState & OPTST_ALLOC_ARG) != 0)
-        pOD->optCookie = (void *)pOD->optArg.argString;
+        pOD->optCookie = VOIDP(pOD->optArg.argString);
     else
         AGDUPSTR(pOD->optCookie, pOD->optArg.argString, "file name");
 
@@ -131,7 +131,7 @@ fopen_file_fp(tOptions * pOpts, tOptDesc * pOD, tuFileMode mode)
         /* NOTREACHED */
 
     if ((pOD->fOptState & OPTST_ALLOC_ARG) != 0)
-        pOD->optCookie = (void *)pOD->optArg.argString;
+        pOD->optCookie = VOIDP(pOD->optArg.argString);
     else
         AGDUPSTR(pOD->optCookie, pOD->optArg.argString, "file name");
 
@@ -143,8 +143,8 @@ fopen_file_fp(tOptions * pOpts, tOptDesc * pOD, tuFileMode mode)
  * private:
  *
  * what:  Decipher a boolean value
- * arg:   + tOptions*     + pOpts    + program options descriptor  +
- * arg:   + tOptDesc*     + pOptDesc + the descriptor for this arg +
+ * arg:   + tOptions *    + pOpts    + program options descriptor  +
+ * arg:   + tOptDesc *    + pOptDesc + the descriptor for this arg +
  * arg:   + teOptFileType + ftype    + File handling type          +
  * arg:   + tuFileMode    + mode     + file open mode (if needed)  +
  *
@@ -153,7 +153,7 @@ fopen_file_fp(tOptions * pOpts, tOptDesc * pOD, tuFileMode mode)
  *   The mode specifies if the file must exist, must not exist or may
  *   (or may not) exist.  The mode may also specify opening the
  *   file: don't, open just the descriptor (fd), or open as a stream
- *   (FILE* pointer).
+ *   (FILE * pointer).
 =*/
 void
 optionFileCheck(tOptions * pOpts, tOptDesc * pOD,
diff --git a/src/libopts/find.c b/src/libopts/find.c
index 1ec02e5..90591cc 100644
--- a/src/libopts/find.c
+++ b/src/libopts/find.c
@@ -12,7 +12,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -58,7 +58,7 @@ static tSuccess
 get_opt_arg_may(tOptions * pOpts, tOptState * o_st);
 
 static tSuccess
-get_opt_arg_none(tOptions * pOpts, tOptState* o_st);
+get_opt_arg_none(tOptions * pOpts, tOptState * o_st);
 /* = = = END-STATIC-FORWARD = = = */
 
 /**
@@ -409,9 +409,9 @@ opt_find_long(tOptions * opts, char const * opt_name, tOptState * state)
  * @param pOptState  state about current option
  */
 LOCAL tSuccess
-opt_find_short(tOptions* pOpts, uint_t optValue, tOptState* pOptState)
+opt_find_short(tOptions * pOpts, uint_t optValue, tOptState * pOptState)
 {
-    tOptDesc*  pRes = pOpts->pOptDesc;
+    tOptDesc * pRes = pOpts->pOptDesc;
     int        ct   = pOpts->optCt;
 
     /*
@@ -554,7 +554,7 @@ get_opt_arg_may(tOptions * pOpts, tOptState * o_st)
         if (*++pOpts->pzCurOpt != NUL)
             o_st->pzOptArg = pOpts->pzCurOpt;
         else {
-            char* pzLA = pOpts->origArgVect[ pOpts->curOptIdx ];
+            char * pzLA = pOpts->origArgVect[ pOpts->curOptIdx ];
 
             /*
              *  BECAUSE it is optional, we must make sure
@@ -577,7 +577,7 @@ get_opt_arg_may(tOptions * pOpts, tOptState * o_st)
          */
         if (  (o_st->pzOptArg == NULL)
            && (! NAMED_OPTS(pOpts))) {
-            char* pzLA = pOpts->origArgVect[ pOpts->curOptIdx ];
+            char * pzLA = pOpts->origArgVect[ pOpts->curOptIdx ];
 
             /*
              *  BECAUSE it is optional, we must make sure
@@ -616,7 +616,7 @@ get_opt_arg_may(tOptions * pOpts, tOptState * o_st)
  *  @returns SUCCESS or FAILURE
  */
 static tSuccess
-get_opt_arg_none(tOptions * pOpts, tOptState* o_st)
+get_opt_arg_none(tOptions * pOpts, tOptState * o_st)
 {
     /*
      *  No option argument.  Make sure next time around we find
@@ -711,7 +711,7 @@ find_opt(tOptions * opts, tOptState * o_st)
          *  strip off the "const" quality of the "default_opt" field.
          */
         while (*(++pz) == '-')   ;
-        def_opt  = (void *)&(opts->specOptIdx.default_opt);
+        def_opt  = VOIDP(&(opts->specOptIdx.default_opt));
         def      = *def_opt;
         *def_opt = NO_EQUIVALENT;
         res      = opt_find_long(opts, pz, o_st);
diff --git a/src/libopts/genshell.c b/src/libopts/genshell.c
index 20e6c15..3933572 100644
--- a/src/libopts/genshell.c
+++ b/src/libopts/genshell.c
@@ -6,7 +6,7 @@
  *  From the definitions    genshell.def
  *  and the template file   options
  *
- * Generated from AutoOpts 41:0:16 templates.
+ * Generated from AutoOpts 41:1:16 templates.
  *
  *  AutoOpts is a copyrighted work.  This source file is not encumbered
  *  by AutoOpts licensing, but is provided under the licensing terms chosen
@@ -294,7 +294,7 @@ doUsageOpt(tOptions * opts, tOptDesc * od)
     (void)opts;
     (void)od;
 }
-/* extracted from optmain.tlib near line 1245 */
+/* extracted from optmain.tlib near line 1250 */
 
 /**
  * The directory containing the data associated with genshellopt.
@@ -406,11 +406,11 @@ AO_gettext(char const * pz)
     if (option_xlateable_txt.field_ct != 0) {
         res = dgettext("libopts", pz);
         if (res == pz)
-            res = (char *)(void *)_(pz);
+            res = (char *)VOIDP(_(pz));
     } else
-        res = (char *)(void *)_(pz);
+        res = (char *)VOIDP(_(pz));
 #else
-    res = (char *)(void *)_(pz);
+    res = (char *)VOIDP(_(pz));
 #endif
     if (res == pz)
         return res;
@@ -447,7 +447,7 @@ translate_option_strings(void)
          *  Do the translations.  The first pointer follows the field count
          *  field.  The field count field is the size of a pointer.
          */
-        char ** ppz = (char**)(void*)&(option_xlateable_txt);
+        char ** ppz = (char**)VOIDP(&(option_xlateable_txt));
         int     ix  = option_xlateable_txt.field_ct;
 
         do {
@@ -457,16 +457,16 @@ translate_option_strings(void)
         /* prevent re-translation and disable "libopts" domain lookup */
         option_xlateable_txt.field_ct = 0;
 
-        coerce_it((void*)&(opts->pzCopyright));
-        coerce_it((void*)&(opts->pzCopyNotice));
-        coerce_it((void*)&(opts->pzFullVersion));
-        coerce_it((void*)&(opts->pzUsageTitle));
-        coerce_it((void*)&(opts->pzExplain));
-        coerce_it((void*)&(opts->pzDetail));
+        coerce_it(VOIDP(&(opts->pzCopyright)));
+        coerce_it(VOIDP(&(opts->pzCopyNotice)));
+        coerce_it(VOIDP(&(opts->pzFullVersion)));
+        coerce_it(VOIDP(&(opts->pzUsageTitle)));
+        coerce_it(VOIDP(&(opts->pzExplain)));
+        coerce_it(VOIDP(&(opts->pzDetail)));
         {
             tOptDesc * od = opts->pOptDesc;
             for (ix = opts->optCt; ix > 0; ix--, od++)
-                coerce_it((void*)&(od->pzText));
+                coerce_it(VOIDP(&(od->pzText)));
         }
     }
 }
@@ -555,19 +555,19 @@ by the newly generated text.  The first '#!' line will be regenerated.\n"));
   puts(_("allocation of %d bytes failed\n"));
 #line 53 "../init.c"
   puts(_("AutoOpts function called without option descriptor\n"));
-#line 90 "../init.c"
+#line 86 "../init.c"
   puts(_("\tThis exceeds the compiled library version:  "));
-#line 88 "../init.c"
+#line 84 "../init.c"
   puts(_("Automated Options Processing Error!\n"
        "\t%s called AutoOpts function with structure version %d:%d:%d.\n"));
 #line 80 "../autoopts.c"
   puts(_("realloc of %d bytes at 0x%p failed\n"));
-#line 92 "../init.c"
+#line 88 "../init.c"
   puts(_("\tThis is less than the minimum library version:  "));
 #line 121 "../version.c"
   puts(_("Automated Options version %s\n"
        "\tCopyright (C) 1999-2014 by Bruce Korb - all rights reserved\n"));
-#line 82 "../makeshell.c"
+#line 87 "../makeshell.c"
   puts(_("(AutoOpts bug):  %s.\n"));
 #line 90 "../reset.c"
   puts(_("optionResetOpt() called, but reset-option not configured"));
@@ -591,9 +591,9 @@ by the newly generated text.  The first '#!' line will be regenerated.\n"));
   puts(_("%s: Command line arguments required\n"));
 #line 43 "../alias.c"
   puts(_("%d %s%s options allowed\n"));
-#line 89 "../makeshell.c"
+#line 94 "../makeshell.c"
   puts(_("%s error %d (%s) calling %s for '%s'\n"));
-#line 301 "../makeshell.c"
+#line 306 "../makeshell.c"
   puts(_("interprocess pipe"));
 #line 168 "../version.c"
   puts(_("error: version option argument '%c' invalid.  Use:\n"
@@ -671,9 +671,9 @@ by the newly generated text.  The first '#!' line will be regenerated.\n"));
   puts(_("Try '%s %s' for more information.\n"));
 #line 45 "../alias.c"
   puts(_("one %s%s option allowed\n"));
-#line 203 "../makeshell.c"
+#line 208 "../makeshell.c"
   puts(_("standard output"));
-#line 938 "../makeshell.c"
+#line 943 "../makeshell.c"
   puts(_("standard output"));
 #line 274 "../usage.c"
   puts(_("standard output"));
@@ -691,9 +691,9 @@ by the newly generated text.  The first '#!' line will be regenerated.\n"));
   puts(_("standard error"));
 #line 175 "../version.c"
   puts(_("standard error"));
-#line 203 "../makeshell.c"
+#line 208 "../makeshell.c"
   puts(_("write"));
-#line 938 "../makeshell.c"
+#line 943 "../makeshell.c"
   puts(_("write"));
 #line 273 "../usage.c"
   puts(_("write"));
@@ -745,7 +745,7 @@ by the newly generated text.  The first '#!' line will be regenerated.\n"));
 #line 380 "../usage.c"
   puts(_("Options are specified by doubled hyphens and their name or by a single\n"
        "hyphen and the flag character.\n"));
-#line 916 "../makeshell.c"
+#line 921 "../makeshell.c"
   puts(_("\n"
        "= = = = = = = =\n\n"
        "This incarnation of genshell will produce\n"
diff --git a/src/libopts/genshell.h b/src/libopts/genshell.h
index 1c18735..c371f52 100644
--- a/src/libopts/genshell.h
+++ b/src/libopts/genshell.h
@@ -6,7 +6,7 @@
  *  From the definitions    genshell.def
  *  and the template file   options
  *
- * Generated from AutoOpts 41:0:16 templates.
+ * Generated from AutoOpts 41:1:16 templates.
  *
  *  AutoOpts is a copyrighted work.  This header file is not encumbered
  *  by AutoOpts licensing, but is provided under the licensing terms chosen
@@ -55,7 +55,7 @@
  *  tolerable version is at least as old as what was current when the header
  *  template was released.
  */
-#define AO_TEMPLATE_VERSION 167936
+#define AO_TEMPLATE_VERSION 167937
 #if (AO_TEMPLATE_VERSION < OPTIONS_MINIMUM_VERSION) \
  || (AO_TEMPLATE_VERSION > OPTIONS_STRUCT_VERSION)
 # error option template version mismatches autoopts/options.h header
diff --git a/src/libopts/gettext.h b/src/libopts/gettext.h
index 9b7416d..7d3ea3c 100644
--- a/src/libopts/gettext.h
+++ b/src/libopts/gettext.h
@@ -1,5 +1,5 @@
 /* Convenience header for conditional use of GNU <libintl.h>.
-   Copyright (C) 1995-1998, 2000-2002, 2004-2006, 2009-2014 Free Software
+   Copyright (C) 1995-1998, 2000-2002, 2004-2006, 2009-2015 Free Software
    Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
diff --git a/src/libopts/init.c b/src/libopts/init.c
index e038ed7..e02e1e1 100644
--- a/src/libopts/init.c
+++ b/src/libopts/init.c
@@ -9,7 +9,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -69,7 +69,7 @@ validate_struct(tOptions * opts, char const * pname)
          */
         if ((opts->fOptSet & OPTPROC_NO_XLAT_MASK) == OPTPROC_NXLAT_OPT)
             opts->fOptSet |= OPTPROC_NXLAT_OPT_CFG;
-        (*opts->pTransProc)();
+        opts->pTransProc();
     }
 
     /*
@@ -81,10 +81,6 @@ validate_struct(tOptions * opts, char const * pname)
        && (  (opts->structVersion > OPTIONS_STRUCT_VERSION  )
           || (opts->structVersion < OPTIONS_MINIMUM_VERSION )
        )  )  {
-
-        static char const ao_ver_string[] =
-            STR(AO_CURRENT)":"STR(AO_REVISION)":"STR(AO_AGE)"\n";
-
         fprintf(stderr, zwrong_ver, pname, NUM_TO_VER(opts->structVersion));
         if (opts->structVersion > OPTIONS_STRUCT_VERSION )
             fputs(ztoo_new, stderr);
@@ -111,9 +107,9 @@ validate_struct(tOptions * opts, char const * pname)
 
         pz = pathfind(getenv("PATH"), (char *)pname, "rx");
         if (pz != NULL)
-            pname = (void *)pz;
+            pname = VOIDP(pz);
 
-        pp  = (char const **)(void **)&(opts->pzProgPath);
+        pp  = (char const **)VOIDP(&(opts->pzProgPath));
         *pp = pname;
 
         /*
diff --git a/src/libopts/intprops.h b/src/libopts/intprops.h
index 6936ad5..2ae151b 100644
--- a/src/libopts/intprops.h
+++ b/src/libopts/intprops.h
@@ -1,6 +1,6 @@
 /* intprops.h -- properties of integer types
 
-   Copyright (C) 2001-2005, 2009-2014 Free Software Foundation, Inc.
+   Copyright (C) 2001-2005, 2009-2015 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
diff --git a/src/libopts/libopts.c b/src/libopts/libopts.c
index a0ff362..a26c924 100644
--- a/src/libopts/libopts.c
+++ b/src/libopts/libopts.c
@@ -2,6 +2,8 @@
 #include "autoopts/project.h"
 #define  LOCAL static
 #include "ao-strs.h"
+static char const ao_ver_string[] =
+    "41:1:16\n";
 #include "autoopts/options.h"
 #include "autoopts/usage-txt.h"
 #include "genshell.h"
diff --git a/src/libopts/load.c b/src/libopts/load.c
index 5c29d96..b5230af 100644
--- a/src/libopts/load.c
+++ b/src/libopts/load.c
@@ -12,7 +12,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -94,10 +94,10 @@ get_realpath(char * buf, size_t b_sz)
  * private:
  *
  * what:  translate and construct a path
- * arg:   + char*       + p_buf     + The result buffer +
- * arg:   + int         + b_sz      + The size of this buffer +
- * arg:   + char const* + fname     + The input name +
- * arg:   + char const* + prg_path  + The full path of the current program +
+ * arg:   + char *       + p_buf     + The result buffer +
+ * arg:   + int          + b_sz      + The size of this buffer +
+ * arg:   + char const * + fname     + The input name +
+ * arg:   + char const * + prg_path  + The full path of the current program +
  *
  * ret-type: bool
  * ret-desc: true if the name was handled, otherwise false.
@@ -225,7 +225,7 @@ add_prog_path(char * buf, int b_sz, char const * fname, char const * prg_path)
     if (strchr(prg_path, DIRCH) != NULL)
         path = prg_path;
     else {
-        path = pathfind(getenv("PATH"), (char*)prg_path, "rx");
+        path = pathfind(getenv("PATH"), (char *)prg_path, "rx");
 
         if (path == NULL)
             return false;
@@ -544,8 +544,8 @@ load_opt_line(tOptions * opts, tOptState * opt_state, char * line,
  *
  * what:  process a string for an option name and value
  *
- * arg:   tOptions*,   opts,  program options descriptor
- * arg:   char const*, line,  NUL-terminated text
+ * arg:   tOptions *,   opts,  program options descriptor
+ * arg:   char const *, line,  NUL-terminated text
  *
  * doc:
  *
diff --git a/src/libopts/m4/libopts.m4 b/src/libopts/m4/libopts.m4
index 1f3b3ce..1a896d9 100644
--- a/src/libopts/m4/libopts.m4
+++ b/src/libopts/m4/libopts.m4
@@ -97,10 +97,10 @@ AC_DEFUN([INVOKE_LIBOPTS_MACROS_FIRST],[
   ])
   AC_CHECK_TYPES([int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t,
   intptr_t, uintptr_t, uint_t, pid_t, size_t, ptrdiff_t])
-  AC_CHECK_SIZEOF(char*, 8)
-  AC_CHECK_SIZEOF(int,   4)
-  AC_CHECK_SIZEOF(long,  8)
-  AC_CHECK_SIZEOF(short, 2)
+  AC_CHECK_SIZEOF(char *, 8)
+  AC_CHECK_SIZEOF(int,    4)
+  AC_CHECK_SIZEOF(long,   8)
+  AC_CHECK_SIZEOF(short,  2)
 
   # ------------
   # AC_CHECK_LIB
@@ -189,14 +189,14 @@ AC_DEFUN([LIBOPTS_WITHLIB_REGEX],[
   Xyes|Xno|X )
     case "X${libopts_cv_with_libregex_root}" in
     Xyes|Xno|X ) libopts_cv_with_libregex_cflags=no ;;
-    * )        libopts_cv_with_libregex_cflags=-I${libopts_cv_with_libregex_root}/include ;;
+    * ) libopts_cv_with_libregex_cflags=-I${libopts_cv_with_libregex_root}/include ;;
     esac
   esac
   case "X${libopts_cv_with_libregex_libs}" in
   Xyes|Xno|X )
     case "X${libopts_cv_with_libregex_root}" in
     Xyes|Xno|X ) libopts_cv_with_libregex_libs=no ;;
-    * )        libopts_cv_with_libregex_libs="-L${libopts_cv_with_libregex_root}/lib -lregex";;
+    * )        libopts_cv_with_libregex_libs="-L${libopts_cv_with_libregex_root}/lib -lregex" ;;
     esac
   esac
   libopts_save_CPPFLAGS="${CPPFLAGS}"
@@ -221,7 +221,7 @@ AC_DEFUN([LIBOPTS_WITHLIB_REGEX],[
 @%:@include <sys/types.h>
 @%:@include REGEX_HEADER
 static regex_t re;
-void comp_re( char const* pzPat ) {
+void comp_re(char const * pzPat) {
   int res = regcomp( &re, pzPat, REG_EXTENDED|REG_ICASE|REG_NEWLINE );
   if (res == 0) return;
   exit( res ); }
@@ -262,8 +262,8 @@ AC_DEFUN([LIBOPTS_RUN_PATHFIND],[
   AC_CACHE_VAL([libopts_cv_run_pathfind],[
   AC_RUN_IFELSE([@%:@include <string.h>
 @%:@include <stdlib.h>
-int main (int argc, char** argv) {
-   char* pz = pathfind( getenv( "PATH" ), "sh", "x" );
+int main (int argc, char ** argv) {
+   char * pz = pathfind( getenv( "PATH" ), "sh", "x" );
    return (pz == 0) ? 1 : 0;
 }],
     [libopts_cv_run_pathfind=yes],[libopts_cv_run_pathfind=no],[libopts_cv_run_pathfind=no]
@@ -305,7 +305,7 @@ AC_DEFUN([LIBOPTS_RUN_REALPATH],[
   AC_CACHE_VAL([libopts_cv_run_realpath],[
   AC_RUN_IFELSE([@%:@include <limits.h>
 @%:@include <stdlib.h>
-int main (int argc, char** argv) {
+int main (int argc, char ** argv) {
 @%:@ifndef PATH_MAX
 choke me!!
 @%:@else
@@ -364,8 +364,8 @@ AC_DEFUN([LIBOPTS_RUN_FOPEN_BINARY],[
   AC_MSG_CHECKING([whether fopen accepts "b" mode])
   AC_CACHE_VAL([libopts_cv_run_fopen_binary],[
   AC_RUN_IFELSE([@%:@include <stdio.h>
-int main (int argc, char** argv) {
-FILE* fp = fopen("conftest.@S|@ac_ext", "rb");
+int main (int argc, char ** argv) {
+FILE * fp = fopen("conftest.@S|@ac_ext", "rb");
 return (fp == NULL) ? 1 : fclose(fp); }],
     [libopts_cv_run_fopen_binary=yes],[libopts_cv_run_fopen_binary=no],[libopts_cv_run_fopen_binary=no]
   ) # end of RUN_IFELSE
@@ -387,8 +387,8 @@ AC_DEFUN([LIBOPTS_RUN_FOPEN_TEXT],[
   AC_MSG_CHECKING([whether fopen accepts "t" mode])
   AC_CACHE_VAL([libopts_cv_run_fopen_text],[
   AC_RUN_IFELSE([@%:@include <stdio.h>
-int main (int argc, char** argv) {
-FILE* fp = fopen("conftest.@S|@ac_ext", "rt");
+int main (int argc, char ** argv) {
+FILE * fp = fopen("conftest.@S|@ac_ext", "rt");
 return (fp == NULL) ? 1 : fclose(fp); }],
     [libopts_cv_run_fopen_text=yes],[libopts_cv_run_fopen_text=no],[libopts_cv_run_fopen_text=no]
   ) # end of RUN_IFELSE
@@ -461,7 +461,7 @@ dnl the config tests that the library needs.  Invoke the
 dnl "INVOKE_LIBOPTS_MACROS" macro iff we are building libopts.
 dnl
 dnl  This file is part of AutoGen.
-dnl  AutoGen Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+dnl  AutoGen Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
 dnl
 dnl  AutoGen is free software: you can redistribute it and/or modify it
 dnl  under the terms of the GNU General Public License as published by the
diff --git a/src/libopts/m4/liboptschk.m4 b/src/libopts/m4/liboptschk.m4
index c71ae10..34d5658 100644
--- a/src/libopts/m4/liboptschk.m4
+++ b/src/libopts/m4/liboptschk.m4
@@ -1,5 +1,5 @@
 # liboptschk.m4 serial 2 (autogen - 5.11.4)
-dnl Copyright (C) 2005-2014 by Bruce Korb - all rights reserved
+dnl Copyright (C) 2005-2015 by Bruce Korb - all rights reserved
 dnl
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
diff --git a/src/libopts/m4/stdnoreturn.m4 b/src/libopts/m4/stdnoreturn.m4
index eea2c1e..0039411 100644
--- a/src/libopts/m4/stdnoreturn.m4
+++ b/src/libopts/m4/stdnoreturn.m4
@@ -1,6 +1,6 @@
 # Check for stdnoreturn.h that conforms to C11.
 
-dnl Copyright 2012-2014 Free Software Foundation, Inc.
+dnl Copyright 2012-2015 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
 dnl with or without modifications, as long as this notice is preserved.
diff --git a/src/libopts/makeshell.c b/src/libopts/makeshell.c
index a0bfcac..a61df42 100644
--- a/src/libopts/makeshell.c
+++ b/src/libopts/makeshell.c
@@ -11,7 +11,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -30,6 +30,11 @@
  *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd
  */
 
+ static inline unsigned char to_uchar (char ch) { return ch; }
+
+#define UPPER(_c) (toupper(to_uchar(_c)))
+#define LOWER(_c) (tolower(to_uchar(_c)))
+
 /* = = = START-STATIC-FORWARD = = = */
 static void
 emit_var_text(char const * prog, char const * var, int fdin);
@@ -101,7 +106,7 @@ fserr_exit(char const * prog, char const * op, char const * fname)
  * private:
  *
  * what:  Decipher a boolean value
- * arg:   + tOptions* + pOpts    + program options descriptor +
+ * arg:   + tOptions * + pOpts    + program options descriptor +
  *
  * doc:
  *  Emit a shell script that will parse the command line options.
@@ -400,9 +405,9 @@ emit_usage(tOptions * opts)
                 break;
         }
 
-        pp  = (char **)(void *)&(opts->pzProgPath);
+        pp  = VOIDP(&(opts->pzProgPath));
         *pp = tm_nm_buf;
-        pp  = (char **)(void *)&(opts->pzProgName);
+        pp  = VOIDP(&(opts->pzProgName));
         *pp = tm_nm_buf;
     }
 
@@ -410,8 +415,8 @@ emit_usage(tOptions * opts)
     text_to_var(opts, TT_USAGE,     NULL);
 
     {
-        tOptDesc* pOptDesc = opts->pOptDesc;
-        int       optionCt = opts->optCt;
+        tOptDesc * pOptDesc = opts->pOptDesc;
+        int        optionCt = opts->optCt;
 
         for (;;) {
             if (pOptDesc->pOptProc == optionPrintVersion) {
@@ -601,8 +606,8 @@ emit_inaction(tOptions * opts, tOptDesc * od)
 static void
 emit_flag(tOptions * opts)
 {
-    tOptDesc* od = opts->pOptDesc;
-    int       opt_ct = opts->optCt;
+    tOptDesc * od = opts->pOptDesc;
+    int        opt_ct = opts->optCt;
 
     fputs(zOptionCase, stdout);
 
@@ -653,7 +658,7 @@ emit_match_expr(char const * name, tOptDesc * cod, tOptions * opts)
              *  They must not be the same.  They cannot be, because it would
              *  not compile correctly if they were.
              */
-            while (toupper(od->pz_Name[match_ct]) == toupper(name[match_ct]))
+            while (UPPER(od->pz_Name[match_ct]) == UPPER(name[match_ct]))
                 match_ct++;
 
             if (match_ct > min_match_ct)
@@ -772,7 +777,7 @@ load_old_output(char const * fname, char const * pname)
      *  Read in all the data as fast as our OS will let us.
      */
     for (;;) {
-        size_t inct = fread((void*)scan, 1, (size_t)stbf.st_size, fp);
+        size_t inct = fread(VOIDP(scan), 1, (size_t)stbf.st_size, fp);
         if (inct == 0)
             break;
 
@@ -845,8 +850,8 @@ open_out(char const * fname, char const * pname)
  * private:
  * what: The usage function for the genshellopt generated program
  *
- * arg:  + tOptions* + opts    + program options descriptor +
- * arg:  + int       + exit_cd + usage text type to produce +
+ * arg:  + tOptions * + opts    + program options descriptor +
+ * arg:  + int        + exit_cd + usage text type to produce +
  *
  * doc:
  *  This function is used to create the usage strings for the option
@@ -901,11 +906,11 @@ genshelloptUsage(tOptions * opts, int exit_cd)
      */
     {
         char *  pz;
-        char ** pp = (char **)(void *)&(optionParseShellOptions->pzProgName);
+        char ** pp = VOIDP(&(optionParseShellOptions->pzProgName));
         AGDUPSTR(pz, optionParseShellOptions->pzPROGNAME, "prog name");
         *pp = pz;
         while (*pz != NUL) {
-            *pz = (char)tolower(*pz);
+            *pz = (char)LOWER(*pz);
             pz++;
         }
     }
diff --git a/src/libopts/nested.c b/src/libopts/nested.c
index 0ec8f08..f4fb226 100644
--- a/src/libopts/nested.c
+++ b/src/libopts/nested.c
@@ -12,7 +12,7 @@
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -53,8 +53,8 @@ static xml_xlate_t const xml_xlate[] = {
 static void
 remove_continuation(char * src);
 
-static char const*
-scan_q_str(char const* pzTxt);
+static char const *
+scan_q_str(char const * pzTxt);
 
 static tOptionValue *
 add_string(void ** pp, char const * name, size_t nm_len,
@@ -64,11 +64,11 @@ static tOptionValue *
 add_bool(void ** pp, char const * name, size_t nm_len,
          char const * val, size_t d_len);
 
-static tOptionValue*
+static tOptionValue *
 add_number(void ** pp, char const * name, size_t nm_len,
            char const * val, size_t d_len);
 
-static tOptionValue*
+static tOptionValue *
 add_nested(void ** pp, char const * name, size_t nm_len,
            char * val, size_t d_len);
 
@@ -98,7 +98,7 @@ sort_list(tArgList * arg_list);
 static void
 remove_continuation(char * src)
 {
-    char* pzD;
+    char * pzD;
 
     do  {
         while (*src == NL)  src++;
@@ -133,8 +133,8 @@ remove_continuation(char * src)
 /**
  *  Find the end of a quoted string, skipping escaped quote characters.
  */
-static char const*
-scan_q_str(char const* pzTxt)
+static char const *
+scan_q_str(char const * pzTxt)
 {
     char q = *(pzTxt++); /* remember the type of quote */
 
@@ -182,7 +182,7 @@ static tOptionValue *
 add_string(void ** pp, char const * name, size_t nm_len,
            char const * val, size_t d_len)
 {
-    tOptionValue* pNV;
+    tOptionValue * pNV;
     size_t sz = nm_len + d_len + sizeof(*pNV);
 
     pNV = AGALOC(sz, "option name/str value pair");
@@ -254,7 +254,7 @@ add_bool(void ** pp, char const * name, size_t nm_len,
     else new_val->v.boolVal = ! IS_FALSE_TYPE_CHAR(*val);
 
     new_val->valType = OPARG_TYPE_BOOLEAN;
-    new_val->pzName = (char*)(new_val + 1);
+    new_val->pzName = (char *)(new_val + 1);
     memcpy(new_val->pzName, name, nm_len);
     new_val->pzName[ nm_len ] = NUL;
     addArgListEntry(pp, new_val);
@@ -272,7 +272,7 @@ add_bool(void ** pp, char const * name, size_t nm_len,
  *
  * @returns the new value structure
  */
-static tOptionValue*
+static tOptionValue *
 add_number(void ** pp, char const * name, size_t nm_len,
            char const * val, size_t d_len)
 {
@@ -291,7 +291,7 @@ add_number(void ** pp, char const * name, size_t nm_len,
         new_val->v.longVal = strtol(val, 0, 0);
 
     new_val->valType = OPARG_TYPE_NUMERIC;
-    new_val->pzName  = (char*)(new_val + 1);
+    new_val->pzName  = (char *)(new_val + 1);
     memcpy(new_val->pzName, name, nm_len);
     new_val->pzName[ nm_len ] = NUL;
     addArgListEntry(pp, new_val);
@@ -309,18 +309,18 @@ add_number(void ** pp, char const * name, size_t nm_len,
  *
  * @returns the new value structure
  */
-static tOptionValue*
+static tOptionValue *
 add_nested(void ** pp, char const * name, size_t nm_len,
            char * val, size_t d_len)
 {
-    tOptionValue* new_val;
+    tOptionValue * new_val;
 
     if (d_len == 0) {
         size_t sz = nm_len + sizeof(*new_val) + 1;
         new_val = AGALOC(sz, "empty nest");
         new_val->v.nestVal = NULL;
         new_val->valType = OPARG_TYPE_HIERARCHY;
-        new_val->pzName = (char*)(new_val + 1);
+        new_val->pzName = (char *)(new_val + 1);
         memcpy(new_val->pzName, name, nm_len);
         new_val->pzName[ nm_len ] = NUL;
 
@@ -341,11 +341,11 @@ add_nested(void ** pp, char const * name, size_t nm_len,
 static char const *
 scan_name(char const * name, tOptionValue * res)
 {
-    tOptionValue* new_val;
-    char const * pzScan = name+1; /* we know first char is a name char */
-    char const * pzVal;
-    size_t       nm_len = 1;
-    size_t       d_len = 0;
+    tOptionValue * new_val;
+    char const *   pzScan = name+1; /* we know first char is a name char */
+    char const *   pzVal;
+    size_t         nm_len = 1;
+    size_t         d_len = 0;
 
     /*
      *  Scan over characters that name a value.  These names may not end
@@ -645,13 +645,13 @@ unload_arg_list(tArgList * arg_list)
     char const ** pnew_val = arg_list->apzArgs;
 
     while (ct-- > 0) {
-        tOptionValue* new_val = (tOptionValue*)(void*)*(pnew_val++);
+        tOptionValue * new_val = (tOptionValue *)VOIDP(*(pnew_val++));
         if (new_val->valType == OPARG_TYPE_HIERARCHY)
             unload_arg_list(new_val->v.nestVal);
         AGFREE(new_val);
     }
 
-    AGFREE((void*)arg_list);
+    AGFREE(arg_list);
 }
 
 /*=export_func  optionUnloadNested
@@ -675,7 +675,7 @@ optionUnloadNested(tOptionValue const * opt_val)
 
     unload_arg_list(opt_val->v.nestVal);
 
-    AGFREE((void*)opt_val);
+    AGFREE(opt_val);
 }
 
 /**
@@ -703,8 +703,8 @@ sort_list(tArgList * arg_list)
          *  "-1" entry.
          */
         while (strcmp(old_v->pzName, new_v->pzName) > 0) {
-            arg_list->apzArgs[iy+1] = (void*)old_v;
-            old_v = (tOptionValue*)(void*)(arg_list->apzArgs[--iy]);
+            arg_list->apzArgs[iy+1] = VOIDP(old_v);
+            old_v = (tOptionValue *)VOIDP(arg_list->apzArgs[--iy]);
             if (iy < 0)
                 break;
         }
@@ -713,7 +713,7 @@ sort_list(tArgList * arg_list)
          *  Always store the pointer.  Sometimes it is redundant,
          *  but the redundancy is cheaper than a test and branch sequence.
          */
-        arg_list->apzArgs[iy+1] = (void*)new_v;
+        arg_list->apzArgs[iy+1] = VOIDP(new_v);
     }
 }
 
@@ -725,7 +725,7 @@ sort_list(tArgList * arg_list)
  * arg:   + char const * + pzName + the name for the text +
  * arg:   + size_t       + nm_len + the length of "name"  +
  *
- * ret_type:  tOptionValue*
+ * ret_type:  tOptionValue *
  * ret_desc:  An allocated, compound value structure
  *
  * doc:
@@ -746,7 +746,7 @@ sort_list(tArgList * arg_list)
 LOCAL tOptionValue *
 optionLoadNested(char const * text, char const * name, size_t nm_len)
 {
-    tOptionValue* res_val;
+    tOptionValue * res_val;
 
     /*
      *  Make sure we have some data and we have space to put what we find.
@@ -762,7 +762,7 @@ optionLoadNested(char const * text, char const * name, size_t nm_len)
     }
     res_val = AGALOC(sizeof(*res_val) + nm_len + 1, "nest args");
     res_val->valType = OPARG_TYPE_HIERARCHY;
-    res_val->pzName  = (char*)(res_val + 1);
+    res_val->pzName  = (char *)(res_val + 1);
     memcpy(res_val->pzName, name, nm_len);
     res_val->pzName[nm_len] = NUL;
 
@@ -814,8 +814,8 @@ optionLoadNested(char const * text, char const * name, size_t nm_len)
  * private:
  *
  * what:  parse a hierarchical option argument
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od   + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od   + the descriptor for this arg +
  *
  * doc:
  *  Nested value was found on the command line
@@ -837,7 +837,7 @@ optionNestedVal(tOptions * opts, tOptDesc * od)
         av = arg_list->apzArgs;
 
         while (--ct >= 0) {
-            void * p = (void *)*(av++);
+            void * p = VOIDP(*(av++));
             optionUnloadNested((tOptionValue const *)p);
         }
 
@@ -848,7 +848,7 @@ optionNestedVal(tOptions * opts, tOptDesc * od)
             od->optArg.argString, od->pz_Name, strlen(od->pz_Name));
 
         if (opt_val != NULL)
-            addArgListEntry(&(od->optCookie), (void*)opt_val);
+            addArgListEntry(&(od->optCookie), VOIDP(opt_val));
     }
 }
 
diff --git a/src/libopts/numeric.c b/src/libopts/numeric.c
index 9baba65..ab8f3d1 100644
--- a/src/libopts/numeric.c
+++ b/src/libopts/numeric.c
@@ -10,7 +10,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -33,10 +33,10 @@
  * private:
  *
  * what:  Show info about range constraints
- * arg:   + tOptions* + pOpts     + program options descriptor  +
- * arg:   + tOptDesc* + pOptDesc  + the descriptor for this arg +
- * arg:   + void *    + rng_table + the value range tables      +
- * arg:   + int       + rng_count + the number of entries       +
+ * arg:   + tOptions * + pOpts     + program options descriptor  +
+ * arg:   + tOptDesc * + pOptDesc  + the descriptor for this arg +
+ * arg:   + void *     + rng_table + the value range tables      +
+ * arg:   + int        + rng_count + the number of entries       +
  *
  * doc:
  *   Show information about a numeric option with range constraints.
@@ -97,8 +97,8 @@ optionShowRange(tOptions * pOpts, tOptDesc * pOD, void * rng_table, int rng_ct)
  * private:
  *
  * what:  process an option with a numeric value.
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od   + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od   + the descriptor for this arg +
  *
  * doc:
  *  Decipher a numeric value.
@@ -106,8 +106,8 @@ optionShowRange(tOptions * pOpts, tOptDesc * pOD, void * rng_table, int rng_ct)
 void
 optionNumericVal(tOptions * opts, tOptDesc * od)
 {
-    char* pz;
-    long  val;
+    char * pz;
+    long   val;
 
     /*
      *  Guard against all the different ways this procedure might get invoked
diff --git a/src/libopts/option-value-type.c b/src/libopts/option-value-type.c
index e4b4ea1..5f67640 100644
--- a/src/libopts/option-value-type.c
+++ b/src/libopts/option-value-type.c
@@ -31,7 +31,7 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "option-value-type.h"
-/* ANSI-C code produced by gperf version 3.0.3 */
+/* ANSI-C code produced by gperf version 3.0.4 */
 /* Command-line: gperf option-value-type.gp  */
 /* Computed positions: -k'1' */
 
diff --git a/src/libopts/option-xat-attribute.c b/src/libopts/option-xat-attribute.c
index 0fffd30..be86041 100644
--- a/src/libopts/option-xat-attribute.c
+++ b/src/libopts/option-xat-attribute.c
@@ -31,7 +31,7 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "option-xat-attribute.h"
-/* ANSI-C code produced by gperf version 3.0.3 */
+/* ANSI-C code produced by gperf version 3.0.4 */
 /* Command-line: gperf option-xat-attribute.gp  */
 /* Computed positions: -k'1' */
 
diff --git a/src/libopts/parse-duration.c b/src/libopts/parse-duration.c
index ff3fe42..e072b7d 100644
--- a/src/libopts/parse-duration.c
+++ b/src/libopts/parse-duration.c
@@ -1,5 +1,5 @@
 /* Parse a time duration and return a seconds count
-   Copyright (C) 2008-2014 Free Software Foundation, Inc.
+   Copyright (C) 2008-2015 Free Software Foundation, Inc.
    Written by Bruce Korb <bkorb@gnu.org>, 2008.
 
    This program is free software: you can redistribute it and/or modify
diff --git a/src/libopts/parse-duration.h b/src/libopts/parse-duration.h
index da7301e..33ddc33 100644
--- a/src/libopts/parse-duration.h
+++ b/src/libopts/parse-duration.h
@@ -1,5 +1,5 @@
 /* Parse a time duration and return a seconds count
-   Copyright (C) 2008-2014 Free Software Foundation, Inc.
+   Copyright (C) 2008-2015 Free Software Foundation, Inc.
    Written by Bruce Korb <bkorb@gnu.org>, 2008.
 
    This program is free software: you can redistribute it and/or modify
diff --git a/src/libopts/pgusage.c b/src/libopts/pgusage.c
index 80a89a7..3d229c1 100644
--- a/src/libopts/pgusage.c
+++ b/src/libopts/pgusage.c
@@ -13,7 +13,7 @@
  *
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -33,7 +33,7 @@
  */
 
 #if defined(HAVE_WORKING_FORK)
-static FILE *
+static inline FILE *
 open_tmp_usage(char ** buf)
 {
     char * bf;
@@ -64,7 +64,7 @@ open_tmp_usage(char ** buf)
     }
 }
 
-static char *
+static inline char *
 mk_pager_cmd(char const * fname)
 {
     /*
@@ -85,10 +85,10 @@ mk_pager_cmd(char const * fname)
         if (pager == NULL)
             pager = MORE_STR;
 
-        bfsz = strlen(fname) + strlen(pager) + PAGE_USAGE_FMT_LEN;
+        bfsz = 2 * strlen(fname) + strlen(pager) + PAGE_USAGE_FMT_LEN;
         res  = AGALOC(bfsz, "more cmd");
         snprintf(res, bfsz, PAGE_USAGE_FMT, pager, fname);
-        AGFREE((void*)fname);
+        AGFREE(fname);
         return res;
     }
 }
diff --git a/src/libopts/proto.h b/src/libopts/proto.h
index 591999f..8ba6646 100644
--- a/src/libopts/proto.h
+++ b/src/libopts/proto.h
@@ -1,7 +1,7 @@
 /* -*- buffer-read-only: t -*- vi: set ro:
  *
  * Prototypes for autoopts
- * Generated Sat Aug 30 10:36:38 PDT 2014
+ * Generated Thu Apr 30 19:55:28 PDT 2015
  */
 #ifndef AUTOOPTS_PROTO_H_GUARD
 #define AUTOOPTS_PROTO_H_GUARD 1
@@ -65,7 +65,7 @@ static tSuccess
 opt_find_long(tOptions * opts, char const * opt_name, tOptState * state);
 
 static tSuccess
-opt_find_short(tOptions* pOpts, uint_t optValue, tOptState* pOptState);
+opt_find_short(tOptions * pOpts, uint_t optValue, tOptState * pOptState);
 
 static tSuccess
 get_opt_arg(tOptions * opts, tOptState * o_st);
diff --git a/src/libopts/putshell.c b/src/libopts/putshell.c
index 4b0fa10..9bfa984 100644
--- a/src/libopts/putshell.c
+++ b/src/libopts/putshell.c
@@ -12,7 +12,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -296,7 +296,7 @@ print_membership(tOptions * pOpts, tOptDesc * pOD)
     uintptr_t val = 1;
     printf(zOptNumFmt, pOpts->pzPROGNAME, pOD->pz_NAME,
            (int)(uintptr_t)(pOD->optCookie));
-    pOD->optCookie = (void*)(uintptr_t)~0UL;
+    pOD->optCookie = VOIDP(~0UL);
     (*(pOD->pOptProc))(OPTPROC_RETURN_VALNAME, pOD);
 
     pz = pOD->optArg.argString;
@@ -323,7 +323,7 @@ print_membership(tOptions * pOpts, tOptDesc * pOD)
 static void
 print_stacked_arg(tOptions * pOpts, tOptDesc * pOD)
 {
-    tArgList*       pAL = (tArgList*)pOD->optCookie;
+    tArgList *      pAL = (tArgList *)pOD->optCookie;
     char const **   ppz = pAL->apzArgs;
     int             ct  = pAL->useCt;
 
@@ -363,19 +363,19 @@ print_reordering(tOptions * opts)
 /*=export_func  optionPutShell
  * what:  write a portable shell script to parse options
  * private:
- * arg:   tOptions*, pOpts, the program options descriptor
+ * arg:   tOptions *, pOpts, the program options descriptor
  * doc:   This routine will emit portable shell script text for parsing
  *        the options described in the option definitions.
 =*/
 void
-optionPutShell(tOptions* pOpts)
+optionPutShell(tOptions * pOpts)
 {
     int  optIx = 0;
 
     printf(zOptCtFmt, pOpts->curOptIdx-1);
 
     do  {
-        tOptDesc* pOD = pOpts->pOptDesc + optIx;
+        tOptDesc * pOD = pOpts->pOptDesc + optIx;
 
         if ((pOD->fOptState & OPTST_NO_OUTPUT_MASK) != 0)
             continue;
@@ -396,7 +396,7 @@ optionPutShell(tOptions* pOpts)
          *  but copy over the set-state bits.
          */
         if (pOD->optActualIndex != optIx) {
-            tOptDesc* p   = pOpts->pOptDesc + pOD->optActualIndex;
+            tOptDesc * p  = pOpts->pOptDesc + pOD->optActualIndex;
             p->optArg     = pOD->optArg;
             p->fOptState &= OPTST_PERSISTENT_MASK;
             p->fOptState |= pOD->fOptState & ~OPTST_PERSISTENT_MASK;
diff --git a/src/libopts/reset.c b/src/libopts/reset.c
index df81cd7..6ca2c05 100644
--- a/src/libopts/reset.c
+++ b/src/libopts/reset.c
@@ -10,7 +10,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -30,7 +30,7 @@
  */
 
 static void
-optionReset( tOptions* pOpts, tOptDesc* pOD )
+optionReset(tOptions * pOpts, tOptDesc * pOD)
 {
     pOD->fOptState &= OPTST_PERSISTENT_MASK;
     pOD->fOptState |= OPTST_RESET;
@@ -63,8 +63,8 @@ optionResetEverything(tOptions * pOpts)
  * private:
  *
  * what:  Reset the value of an option
- * arg:   + tOptions* + pOpts    + program options descriptor  +
- * arg:   + tOptDesc* + pOptDesc + the descriptor for this arg +
+ * arg:   + tOptions * + pOpts    + program options descriptor  +
+ * arg:   + tOptDesc * + pOptDesc + the descriptor for this arg +
  *
  * doc:
  *  This code will cause another option to be reset to its initial state.
diff --git a/src/libopts/restore.c b/src/libopts/restore.c
index f711cb3..02ef14a 100644
--- a/src/libopts/restore.c
+++ b/src/libopts/restore.c
@@ -12,7 +12,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -38,11 +38,11 @@
  *  have been marked as allocated though.
  */
 static void
-fixupSavedOptionArgs(tOptions* pOpts)
+fixupSavedOptionArgs(tOptions * pOpts)
 {
-    tOptions* p   = pOpts->pSavedState;
-    tOptDesc* pOD = pOpts->pOptDesc;
-    int       ct  = pOpts->optCt;
+    tOptions * p   = pOpts->pSavedState;
+    tOptDesc * pOD = pOpts->pOptDesc;
+    int        ct  = pOpts->optCt;
 
     /*
      *  Make sure that allocated stuff is only referenced in the
@@ -52,18 +52,18 @@ fixupSavedOptionArgs(tOptions* pOpts)
         switch (OPTST_GET_ARGTYPE(pOD->fOptState)) {
         case OPARG_TYPE_STRING:
             if (pOD->fOptState & OPTST_STACKED) {
-                tOptDesc* q = p->pOptDesc + (pOD - pOpts->pOptDesc);
+                tOptDesc * q = p->pOptDesc + (pOD - pOpts->pOptDesc);
                 q->optCookie = NULL;
             }
             if (pOD->fOptState & OPTST_ALLOC_ARG) {
-                tOptDesc* q = p->pOptDesc + (pOD - pOpts->pOptDesc);
+                tOptDesc * q = p->pOptDesc + (pOD - pOpts->pOptDesc);
                 AGDUPSTR(q->optArg.argString, pOD->optArg.argString, "arg");
             }
             break;
 
         case OPARG_TYPE_HIERARCHY:
         {
-            tOptDesc* q = p->pOptDesc + (pOD - pOpts->pOptDesc);
+            tOptDesc * q = p->pOptDesc + (pOD - pOpts->pOptDesc);
             q->optCookie = NULL;
         }
         }
@@ -73,7 +73,7 @@ fixupSavedOptionArgs(tOptions* pOpts)
 /*=export_func optionSaveState
  *
  * what:  saves the option state to memory
- * arg:   tOptions*, pOpts, program options descriptor
+ * arg:   tOptions *, pOpts, program options descriptor
  *
  * doc:
  *
@@ -96,7 +96,7 @@ fixupSavedOptionArgs(tOptions* pOpts)
 void
 optionSaveState(tOptions * pOpts)
 {
-    tOptions * p = (tOptions*)pOpts->pSavedState;
+    tOptions * p = (tOptions *)pOpts->pSavedState;
 
     if (p == NULL) {
         size_t sz = sizeof(*pOpts)
@@ -116,7 +116,7 @@ optionSaveState(tOptions * pOpts)
 /*=export_func optionRestore
  *
  * what:  restore option state from memory copy
- * arg:   tOptions*, pOpts, program options descriptor
+ * arg:   tOptions *, pOpts, program options descriptor
  *
  * doc:  Copy back the option state from saved memory.
  *       The allocated memory is left intact, so this routine can be
@@ -129,9 +129,9 @@ optionSaveState(tOptions * pOpts)
  *       printed to @code{stderr} and exit is called.
 =*/
 void
-optionRestore(tOptions* pOpts)
+optionRestore(tOptions * pOpts)
 {
-    tOptions* p = (tOptions*)pOpts->pSavedState;
+    tOptions * p = (tOptions *)pOpts->pSavedState;
 
     if (p == NULL) {
         char const * pzName = pOpts->pzProgName;
@@ -159,7 +159,7 @@ optionRestore(tOptions* pOpts)
 /*=export_func optionFree
  *
  * what:  free allocated option processing memory
- * arg:   tOptions*, pOpts, program options descriptor
+ * arg:   tOptions *, pOpts, program options descriptor
  *
  * doc:   AutoOpts sometimes allocates memory and puts pointers to it in the
  *        option state structures.  This routine deallocates all such memory.
@@ -168,11 +168,11 @@ optionRestore(tOptions* pOpts)
  *        this routine is always successful.
 =*/
 void
-optionFree(tOptions* pOpts)
+optionFree(tOptions * pOpts)
 {
  free_saved_state:
     {
-        tOptDesc* p = pOpts->pOptDesc;
+        tOptDesc * p = pOpts->pOptDesc;
         int ct = pOpts->optCt;
         do  {
             if (p->fOptState & OPTST_ALLOC_ARG) {
@@ -204,7 +204,7 @@ optionFree(tOptions* pOpts)
         } while (p++, --ct > 0);
     }
     if (pOpts->pSavedState != NULL) {
-        tOptions * p = (tOptions*)pOpts->pSavedState;
+        tOptions * p = (tOptions *)pOpts->pSavedState;
         memcpy(pOpts, p, sizeof(*p));
         memcpy(pOpts->pOptDesc, p+1, (size_t)p->optCt * sizeof(tOptDesc));
         AGFREE(pOpts->pSavedState);
diff --git a/src/libopts/save.c b/src/libopts/save.c
index 19c4c5b..f462ced 100644
--- a/src/libopts/save.c
+++ b/src/libopts/save.c
@@ -12,7 +12,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -92,7 +92,7 @@ find_dir_name(tOptions * opts, int * p_free)
      *  we can stash the RC (INI) file.
      */
     {
-        char const * const* papz = opts->papzHomeList;
+        char const * const * papz = opts->papzHomeList;
         if (papz == NULL)
             return NULL;
 
@@ -183,7 +183,7 @@ find_file_name(tOptions * opts, int * p_free_name)
             fprintf(stderr, zsave_warn, opts->pzProgName);
             fprintf(stderr, zNoStat, errno, strerror(errno), pzDir);
             if (free_dir_name)
-                AGFREE((void*)pzDir);
+                AGFREE(pzDir);
             return NULL;
         }
 
@@ -216,14 +216,14 @@ find_file_name(tOptions * opts, int * p_free_name)
         size_t sz = strlen(pzDir) + strlen(opts->pzRcName) + 2;
 
         {
-            char * pzPath = (char*)AGALOC(sz, "file name");
+            char * pzPath = (char *)AGALOC(sz, "file name");
 #ifdef HAVE_SNPRINTF
             snprintf(pzPath, sz, "%s/%s", pzDir, opts->pzRcName);
 #else
             sprintf(pzPath, "%s/%s", pzDir, opts->pzRcName);
 #endif
             if (free_dir_name)
-                AGFREE((void*)pzDir);
+                AGFREE(pzDir);
             pzDir = pzPath;
             free_dir_name = 1;
         }
@@ -237,7 +237,7 @@ find_file_name(tOptions * opts, int * p_free_name)
                 fprintf(stderr, zsave_warn, opts->pzProgName);
                 fprintf(stderr, zNoStat, errno, strerror(errno),
                         pzDir);
-                AGFREE((void*)pzDir);
+                AGFREE(pzDir);
                 return NULL;
             }
 
@@ -255,7 +255,7 @@ find_file_name(tOptions * opts, int * p_free_name)
     if (! S_ISREG(stBuf.st_mode)) {
         fprintf(stderr, zsave_warn, opts->pzProgName, pzDir);
         if (free_dir_name)
-            AGFREE((void*)pzDir);
+            AGFREE(pzDir);
         return NULL;
     }
 
@@ -306,7 +306,7 @@ prt_entry(FILE * fp, tOptDesc * od, char const * l_arg)
      *  THEN the char pointer is really the number
      */
     if (OPTST_GET_ARGTYPE(od->fOptState) == OPARG_TYPE_NUMERIC)
-        fprintf(fp, "%d", (int)(t_word)l_arg);
+        fprintf(fp, "%d", (int)(intptr_t)l_arg);
 
     else {
         for (;;) {
@@ -377,7 +377,7 @@ prt_value(FILE * fp, int depth, tOptDesc * pOD, tOptionValue const * ovp)
                     /*
                      *  set membership strings get allocated
                      */
-                    AGFREE((void*)pOD->optArg.argString);
+                    AGFREE(pOD->optArg.argString);
                 }
             }
 
@@ -534,12 +534,12 @@ open_sv_file(tOptions * opts)
             fprintf(stderr, zsave_warn, opts->pzProgName);
             fprintf(stderr, zNoCreat, errno, strerror(errno), pzFName);
             if (free_name)
-                AGFREE((void*) pzFName );
+                AGFREE(pzFName);
             return fp;
         }
 
         if (free_name)
-            AGFREE((void*)pzFName);
+            AGFREE(pzFName);
     }
 
     fputs("#  ", fp);
@@ -560,7 +560,7 @@ open_sv_file(tOptions * opts)
          *  normally point to static data that is overwritten by each call.
          *  The test to detect allocated ctime, so we leak the memory.
          */
-        AGFREE((void*)time_str);
+        AGFREE(time_str);
 #endif
     }
 
@@ -596,7 +596,7 @@ static void
 prt_str_arg(FILE * fp, tOptDesc * pOD)
 {
     if (pOD->fOptState & OPTST_STACKED) {
-        tArgList * pAL = (tArgList*)pOD->optCookie;
+        tArgList * pAL = (tArgList *)pOD->optCookie;
         int        uct = pAL->useCt;
         char const ** ppz = pAL->apzArgs;
 
@@ -629,7 +629,7 @@ prt_enum_arg(FILE * fp, tOptDesc * od)
      *  bit flag values back into a string suitable for printing.
      */
     (*(od->pOptProc))(OPTPROC_RETURN_VALNAME, od);
-    prt_entry(fp, od, (void*)(od->optArg.argString));
+    prt_entry(fp, od, VOIDP(od->optArg.argString));
 
     od->optArg.argEnum = val;
 }
@@ -689,7 +689,7 @@ prt_file_arg(FILE * fp, tOptDesc * od, tOptions * opts)
  *
  * what:  saves the option state to a file
  *
- * arg:   tOptions*,   opts,  program options descriptor
+ * arg:   tOptions *,   opts,  program options descriptor
  *
  * doc:
  *
@@ -765,7 +765,7 @@ optionSaveFile(tOptions * opts)
             break;
 
         case OPARG_TYPE_NUMERIC:
-            prt_entry(fp, p, (void*)(p->optArg.argInt));
+            prt_entry(fp, p, VOIDP(p->optArg.argInt));
             break;
 
         case OPARG_TYPE_STRING:
diff --git a/src/libopts/sort.c b/src/libopts/sort.c
index 894d0ec..da00334 100644
--- a/src/libopts/sort.c
+++ b/src/libopts/sort.c
@@ -10,7 +10,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -198,11 +198,11 @@ optionSort(tOptions * opts)
     /*
      *  Make sure we can allocate two full-sized arg vectors.
      */
-    opt_txt = malloc(opts->origArgCt * sizeof(char*));
+    opt_txt = malloc(opts->origArgCt * sizeof(char *));
     if (opt_txt == NULL)
         goto exit_no_mem;
 
-    ppzOpds = malloc(opts->origArgCt * sizeof(char*));
+    ppzOpds = malloc(opts->origArgCt * sizeof(char *));
     if (ppzOpds == NULL) {
         free(opt_txt);
         goto exit_no_mem;
@@ -315,10 +315,10 @@ optionSort(tOptions * opts)
  joinLists:
     if (optsIdx > 0)
         memcpy(opts->origArgVect + 1, opt_txt,
-               (size_t)optsIdx * sizeof(char*));
+               (size_t)optsIdx * sizeof(char *));
     if (opdsIdx > 0)
         memcpy(opts->origArgVect + 1 + optsIdx, ppzOpds,
-               (size_t)opdsIdx * sizeof(char*));
+               (size_t)opdsIdx * sizeof(char *));
 
  freeTemps:
     free(opt_txt);
diff --git a/src/libopts/stack.c b/src/libopts/stack.c
index d2ce165..affe6b6 100644
--- a/src/libopts/stack.c
+++ b/src/libopts/stack.c
@@ -11,7 +11,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -38,8 +38,8 @@
  * private:
  *
  * what:  Remove option args from a stack
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od   + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od   + the descriptor for this arg +
  *
  * doc:
  *  Invoked for options that are equivalenced to stacked options.
@@ -52,7 +52,7 @@ optionUnstackArg(tOptions * opts, tOptDesc * od)
     if (INQUERY_CALL(opts, od))
         return;
 
-    arg_list = (tArgList*)od->optCookie;
+    arg_list = (tArgList *)od->optCookie;
 
     /*
      *  IF we don't have any stacked options,
@@ -165,7 +165,7 @@ optionUnstackArg(tOptions * opts, tOptDesc * od)
         od->fOptState &= OPTST_PERSISTENT_MASK;
         if ((od->fOptState & OPTST_INITENABLED) == 0)
             od->fOptState |= OPTST_DISABLED;
-        AGFREE((void *)arg_list);
+        AGFREE(arg_list);
         od->optCookie = NULL;
     }
 }
@@ -179,19 +179,19 @@ optionUnstackArg(tOptions * opts, tOptDesc * od)
 LOCAL void
 addArgListEntry(void ** ppAL, void * entry)
 {
-    tArgList* pAL = *(void**)ppAL;
+    tArgList * pAL = *(void **)ppAL;
 
     /*
      *  IF we have never allocated one of these,
      *  THEN allocate one now
      */
     if (pAL == NULL) {
-        pAL = (tArgList*)AGALOC(sizeof(*pAL), "new option arg stack");
+        pAL = (tArgList *)AGALOC(sizeof(*pAL), "new option arg stack");
         if (pAL == NULL)
             return;
         pAL->useCt   = 0;
         pAL->allocCt = MIN_ARG_ALLOC_CT;
-        *ppAL = (void*)pAL;
+        *ppAL = VOIDP(pAL);
     }
 
     /*
@@ -206,11 +206,11 @@ addArgListEntry(void ** ppAL, void * entry)
          *  The base structure contains space for MIN_ARG_ALLOC_CT
          *  pointers.  We subtract it off to find our augment size.
          */
-        sz += sizeof(char*) * ((size_t)pAL->allocCt - MIN_ARG_ALLOC_CT);
-        pAL = (tArgList*)AGREALOC((void*)pAL, sz, "expanded opt arg stack");
+        sz += sizeof(char *) * ((size_t)pAL->allocCt - MIN_ARG_ALLOC_CT);
+        pAL = (tArgList *)AGREALOC(VOIDP(pAL), sz, "expanded opt arg stack");
         if (pAL == NULL)
             return;
-        *ppAL = (void*)pAL;
+        *ppAL = VOIDP(pAL);
     }
 
     /*
@@ -224,8 +224,8 @@ addArgListEntry(void ** ppAL, void * entry)
  * private:
  *
  * what:  put option args on a stack
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od   + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od   + the descriptor for this arg +
  *
  * doc:
  *  Keep an entry-ordered list of option arguments.
@@ -239,7 +239,7 @@ optionStackArg(tOptions * opts, tOptDesc * od)
         return;
 
     if ((od->fOptState & OPTST_RESET) != 0) {
-        tArgList * arg_list = (void*)od->optCookie;
+        tArgList * arg_list = od->optCookie;
         int ix;
         if (arg_list == NULL)
             return;
@@ -254,7 +254,7 @@ optionStackArg(tOptions * opts, tOptDesc * od)
             return;
 
         AGDUPSTR(pz, od->optArg.argString, "stack arg");
-        addArgListEntry(&(od->optCookie), (void*)pz);
+        addArgListEntry(&(od->optCookie), VOIDP(pz));
     }
 }
 /** @}
diff --git a/src/libopts/stdnoreturn.in.h b/src/libopts/stdnoreturn.in.h
index d4ae183..5b4d11b 100644
--- a/src/libopts/stdnoreturn.in.h
+++ b/src/libopts/stdnoreturn.in.h
@@ -1,6 +1,6 @@
 /* A substitute for ISO C11 <stdnoreturn.h>.
 
-   Copyright 2012-2014 Free Software Foundation, Inc.
+   Copyright 2012-2015 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
diff --git a/src/libopts/streqvcmp.c b/src/libopts/streqvcmp.c
index 371d7f4..e87a232 100644
--- a/src/libopts/streqvcmp.c
+++ b/src/libopts/streqvcmp.c
@@ -15,7 +15,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -81,9 +81,9 @@ static unsigned char charmap[] = {
  *
  * what: compare two strings with an equivalence mapping
  *
- * arg:  + char const* + str1 + first string +
- * arg:  + char const* + str2 + second string +
- * arg:  + int         + ct   + compare length +
+ * arg:  + char const * + str1 + first string +
+ * arg:  + char const * + str2 + second string +
+ * arg:  + int          + ct   + compare length +
  *
  * ret_type:  int
  * ret_desc:  the difference between two differing characters
@@ -129,8 +129,8 @@ strneqvcmp(char const * s1, char const * s2, int ct)
  *
  * what: compare two strings with an equivalence mapping
  *
- * arg:  + char const* + str1 + first string +
- * arg:  + char const* + str2 + second string +
+ * arg:  + char const * + str1 + first string +
+ * arg:  + char const * + str2 + second string +
  *
  * ret_type:  int
  * ret_desc:  the difference between two differing characters
@@ -226,7 +226,7 @@ streqvmap(char from, char to, int ct)
  *
  * what: map a list of characters to the same value
  *
- * arg:  + char const* + ch_list + characters to equivalence +
+ * arg:  + char const * + ch_list + characters to equivalence +
  *
  * doc:
  *
@@ -238,7 +238,7 @@ streqvmap(char from, char to, int ct)
  * err:  none.
 =*/
 void
-strequate(char const* s)
+strequate(char const * s)
 {
     if ((s != NULL) && (*s != NUL)) {
         unsigned char equiv = (unsigned char)*s;
@@ -252,8 +252,8 @@ strequate(char const* s)
  *
  * what: convert a string into its mapped-to value
  *
- * arg:  + char*       + dest + output string +
- * arg:  + char const* + src  + input string +
+ * arg:  + char *       + dest + output string +
+ * arg:  + char const * + src  + input string +
  *
  * doc:
  *
@@ -267,7 +267,7 @@ strequate(char const* s)
  * err:  none.
 =*/
 void
-strtransform(char* d, char const* s)
+strtransform(char * d, char const * s)
 {
     do  {
         *(d++) = (char)charmap[(unsigned char)*s];
diff --git a/src/libopts/text_mmap.c b/src/libopts/text_mmap.c
index f30e71c..07c0bf1 100644
--- a/src/libopts/text_mmap.c
+++ b/src/libopts/text_mmap.c
@@ -9,7 +9,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -61,7 +61,7 @@
 #define FILE_WRITABLE(_prt,_flg) \
         (   (_prt & PROT_WRITE) \
          && ((_flg & (MAP_SHARED|MAP_PRIVATE)) == MAP_SHARED))
-#define MAP_FAILED_PTR ((void*)MAP_FAILED)
+#define MAP_FAILED_PTR (VOIDP(MAP_FAILED))
 
 /**
  * Load the contents of a text file.  There are two separate implementations,
@@ -93,7 +93,7 @@ load_text_file(tmap_info_t * mapinfo, char const * pzFile)
 
     {
         size_t sz = mapinfo->txt_size;
-        char*  pz = mapinfo->txt_data;
+        char * pz = mapinfo->txt_data;
 
         while (sz > 0) {
             ssize_t rdct = read(mapinfo->txt_fd, pz, sz);
@@ -254,12 +254,12 @@ close_mmap_files(tmap_info_t * mi)
  *
  * what:  map a text file with terminating NUL
  *
- * arg:   char const*,  pzFile,  name of the file to map
- * arg:   int,          prot,    mmap protections (see mmap(2))
- * arg:   int,          flags,   mmap flags (see mmap(2))
- * arg:   tmap_info_t*, mapinfo, returned info about the mapping
+ * arg:   char const *,  pzFile,  name of the file to map
+ * arg:   int,           prot,    mmap protections (see mmap(2))
+ * arg:   int,           flags,   mmap flags (see mmap(2))
+ * arg:   tmap_info_t *, mapinfo, returned info about the mapping
  *
- * ret-type:   void*
+ * ret-type:   void *
  * ret-desc:   The mmaped data address
  *
  * doc:
@@ -296,7 +296,7 @@ close_mmap_files(tmap_info_t * mi)
  * #include <mylib.h>
  * tmap_info_t mi;
  * int no_nul;
- * void* data = text_mmap("file", PROT_WRITE, MAP_PRIVATE, &mi);
+ * void * data = text_mmap("file", PROT_WRITE, MAP_PRIVATE, &mi);
  * if (data == MAP_FAILED) return;
  * no_nul = (mi.txt_size == mi.txt_full_size);
  * << use the data >>
@@ -327,7 +327,7 @@ text_mmap(char const * pzFile, int prot, int flags, tmap_info_t * mi)
  *
  * what:  unmap the data mapped in by text_mmap
  *
- * arg:   tmap_info_t*, mapinfo, info about the mapping
+ * arg:   tmap_info_t *, mapinfo, info about the mapping
  *
  * ret-type:   int
  * ret-desc:   -1 or 0.  @code{errno} will have the error code.
diff --git a/src/libopts/time.c b/src/libopts/time.c
index 517d5b1..62e0754 100644
--- a/src/libopts/time.c
+++ b/src/libopts/time.c
@@ -8,7 +8,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -31,8 +31,8 @@
  * private:
  *
  * what:  process an option with a time duration.
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od   + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od   + the descriptor for this arg +
  *
  * doc:
  *  Decipher a time duration value.
@@ -64,8 +64,8 @@ optionTimeVal(tOptions * opts, tOptDesc * od)
  * private:
  *
  * what:  process an option with a time and date.
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od   + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od   + the descriptor for this arg +
  *
  * doc:
  *  Decipher a time and date value.
diff --git a/src/libopts/tokenize.c b/src/libopts/tokenize.c
index 34abf83..cbff7fb 100644
--- a/src/libopts/tokenize.c
+++ b/src/libopts/tokenize.c
@@ -9,7 +9,7 @@
  *  This file defines the string_tokenize interface
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -36,20 +36,20 @@
 
 /* = = = START-STATIC-FORWARD = = = */
 static void
-copy_cooked(ch_t** ppDest, char const ** ppSrc);
+copy_cooked(ch_t ** ppDest, char const ** ppSrc);
 
 static void
-copy_raw(ch_t** ppDest, char const ** ppSrc);
+copy_raw(ch_t ** ppDest, char const ** ppSrc);
 
 static token_list_t *
 alloc_token_list(char const * str);
 /* = = = END-STATIC-FORWARD = = = */
 
 static void
-copy_cooked(ch_t** ppDest, char const ** ppSrc)
+copy_cooked(ch_t ** ppDest, char const ** ppSrc)
 {
-    ch_t* pDest = (ch_t*)*ppDest;
-    const ch_t* pSrc  = (const ch_t*)(*ppSrc + 1);
+    ch_t * pDest = (ch_t *)*ppDest;
+    const ch_t * pSrc  = (const ch_t *)(*ppSrc + 1);
 
     for (;;) {
         ch_t ch = *(pSrc++);
@@ -57,7 +57,7 @@ copy_cooked(ch_t** ppDest, char const ** ppSrc)
         case NUL:   *ppSrc = NULL; return;
         case '"':   goto done;
         case '\\':
-            pSrc += ao_string_cook_escape_char((char*)pSrc, (char*)&ch, 0x7F);
+            pSrc += ao_string_cook_escape_char((char *)pSrc, (char *)&ch, 0x7F);
             if (ch == 0x7F)
                 break;
             /* FALLTHROUGH */
@@ -68,16 +68,16 @@ copy_cooked(ch_t** ppDest, char const ** ppSrc)
     }
 
  done:
-    *ppDest = (ch_t*)pDest; /* next spot for storing character */
+    *ppDest = (ch_t *)pDest; /* next spot for storing character */
     *ppSrc  = (char const *)pSrc;  /* char following closing quote    */
 }
 
 
 static void
-copy_raw(ch_t** ppDest, char const ** ppSrc)
+copy_raw(ch_t ** ppDest, char const ** ppSrc)
 {
-    ch_t* pDest = *ppDest;
-    cc_t* pSrc  = (cc_t*) (*ppSrc + 1);
+    ch_t * pDest = *ppDest;
+    cc_t * pSrc  = (cc_t *) (*ppSrc + 1);
 
     for (;;) {
         ch_t ch = *(pSrc++);
@@ -151,12 +151,12 @@ alloc_token_list(char const * str)
         } while (*pz != NUL);
 
         res = malloc(sizeof(*res) + (size_t)(pz - str)
-                     + ((size_t)max_token_ct * sizeof(ch_t*)));
+                     + ((size_t)max_token_ct * sizeof(ch_t *)));
     }
 
     if (res == NULL)
         errno = ENOMEM;
-    else res->tkn_list[0] = (ch_t*)(res->tkn_list + (max_token_ct - 1));
+    else res->tkn_list[0] = (ch_t *)(res->tkn_list + (max_token_ct - 1));
 
     return res;
 
@@ -170,9 +170,9 @@ alloc_token_list(char const * str)
  *
  * what: tokenize an input string
  *
- * arg:  + char const* + string + string to be tokenized +
+ * arg:  + char const * + string + string to be tokenized +
  *
- * ret_type:  token_list_t*
+ * ret_type:  token_list_t *
  * ret_desc:  pointer to a structure that lists each token
  *
  * doc:
@@ -213,7 +213,7 @@ alloc_token_list(char const * str)
  * @example
  *    #include <stdlib.h>
  *    int ix;
- *    token_list_t* ptl = ao_string_tokenize(some_string)
+ *    token_list_t * ptl = ao_string_tokenize(some_string)
  *    for (ix = 0; ix < ptl->tkn_ct; ix++)
  *       do_something_with_tkn(ptl->tkn_list[ix]);
  *    free(ptl);
@@ -231,11 +231,11 @@ alloc_token_list(char const * str)
  *  @code{ENOMEM} - There is not enough memory.
  *  @end itemize
 =*/
-token_list_t*
-ao_string_tokenize(char const* str)
+token_list_t *
+ao_string_tokenize(char const * str)
 {
-    token_list_t* res = alloc_token_list(str);
-    ch_t* pzDest;
+    token_list_t * res = alloc_token_list(str);
+    ch_t * pzDest;
 
     /*
      *  Now copy each token into the output buffer.
@@ -243,7 +243,7 @@ ao_string_tokenize(char const* str)
     if (res == NULL)
         return res;
 
-    pzDest = (ch_t*)(res->tkn_list[0]);
+    pzDest = (ch_t *)(res->tkn_list[0]);
     res->tkn_ct  = 0;
 
     do  {
@@ -304,15 +304,15 @@ ao_string_tokenize(char const* str)
 #include <string.h>
 
 int
-main(int argc, char** argv)
+main(int argc, char ** argv)
 {
     if (argc == 1) {
         printf("USAGE:  %s arg [ ... ]\n", *argv);
         return 1;
     }
     while (--argc > 0) {
-        char* arg = *(++argv);
-        token_list_t* p = ao_string_tokenize(arg);
+        char * arg = *(++argv);
+        token_list_t * p = ao_string_tokenize(arg);
         if (p == NULL) {
             printf("Parsing string ``%s'' failed:\n\terrno %d (%s)\n",
                    arg, errno, strerror(errno));
diff --git a/src/libopts/usage.c b/src/libopts/usage.c
index 206235d..c652da7 100644
--- a/src/libopts/usage.c
+++ b/src/libopts/usage.c
@@ -18,7 +18,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -240,7 +240,7 @@ skip_misuse_usage(tOptions * pOpts)
 /*=export_func  optionOnlyUsage
  *
  * what:  Print usage text for just the options
- * arg:   + tOptions*   + pOpts    + program options descriptor +
+ * arg:   + tOptions *  + pOpts    + program options descriptor +
  * arg:   + int         + ex_code  + exit code for calling exit(3) +
  *
  * doc:
@@ -435,7 +435,7 @@ print_one_paragraph(char const * text, bool plain, FILE * fp)
     else {
         char const * t = optionQuoteString(text, LINE_SPLICE);
         fprintf(fp, PUTS_FMT, t);
-        AGFREE((void *)t);
+        AGFREE(t);
     }
 }
  
@@ -546,15 +546,15 @@ optionPrintParagraphs(char const * text, bool plain, FILE * fp)
             buf = scan;
         }
     }
-    AGFREE((void *)text);
+    AGFREE(text);
 }
 
 /*=export_func  optionUsage
  * private:
  *
  * what:  Print usage text
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + int       + exitCode + exit code for calling exit(3) +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + int        + exitCode + exit code for calling exit(3) +
  *
  * doc:
  *  This routine will print usage in both GNU-standard and AutoOpts-expanded
diff --git a/src/libopts/version.c b/src/libopts/version.c
index 1516c14..8a8de75 100644
--- a/src/libopts/version.c
+++ b/src/libopts/version.c
@@ -10,7 +10,7 @@
 /*
  *  This file is part of AutoOpts, a companion to AutoGen.
  *  AutoOpts is free software.
- *  AutoOpts is Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
+ *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
  *
  *  AutoOpts is available under any one of two licenses.  The license
  *  in use must be one of these two and the choice is under the control
@@ -32,13 +32,13 @@
 /*=export_func  optionVersion
  *
  * what:     return the compiled AutoOpts version number
- * ret_type: char const*
+ * ret_type: char const *
  * ret_desc: the version string in constant memory
  * doc:
  *  Returns the full version string compiled into the library.
  *  The returned string cannot be modified.
 =*/
-char const*
+char const *
 optionVersion(void)
 {
     static char const ver[] = OPTIONS_DOTTED_VERSION;
@@ -181,8 +181,8 @@ print_ver(tOptions * opts, tOptDesc * od, FILE * fp, bool call_exit)
 /*=export_func  optionPrintVersion
  *
  * what:  Print the program version
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od   + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od   + the descriptor for this arg +
  *
  * doc:
  *  This routine will print the version to stdout.
@@ -196,8 +196,8 @@ optionPrintVersion(tOptions * opts, tOptDesc * od)
 /*=export_func  optionPrintVersionAndReturn
  *
  * what:  Print the program version
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od   + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od   + the descriptor for this arg +
  *
  * doc:
  *  This routine will print the version to stdout and return
@@ -215,8 +215,8 @@ optionPrintVersionAndReturn(tOptions * opts, tOptDesc * od)
  * private:
  *
  * what:  Print the program version to stderr
- * arg:   + tOptions* + opts + program options descriptor +
- * arg:   + tOptDesc* + od   + the descriptor for this arg +
+ * arg:   + tOptions * + opts + program options descriptor +
+ * arg:   + tOptDesc * + od   + the descriptor for this arg +
  *
  * doc:
  *  This routine will print the version to stderr.
-- 
2.5.0

